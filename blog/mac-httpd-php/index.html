<!DOCTYPE html>
<html lang="en-US">
<head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<meta name="description" content="htr3n&#39;s blog -- thoughts and rants about everything">
<meta name="keywords" content="blog,java,php,python,javascript,shell,thoughts,rants">

<base href="/">

<title>htr3n</title>

<meta name="generator" content="Hugo 0.34-DEV" />




<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">


<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,400|Roboto+Slab:400,700|Roboto:300,300i,400,400i,500,500i,700,700i">
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css">
<link rel="stylesheet" href="/css/main.css">




<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<meta name="theme-color" content="#ffffff">

</head>
<body lang="en-US">
<div class="container">


<header class="row text-left title">
  <h1 class="title">Setting up Apache httpd 2.4 and PHP 7 in macOS</h1>
</header>
<section id="category-pane" class="row meta">
  
  <div class="col-md-12">
    <h6 class="text-left meta">
        PUBLISHED ON SEP 25, 2017 
      
      
      
      —
      
      
      <a class="meta" href="/categories/dev">DEV</a>
      
      
      
    </h6>
  </div>
  
</section>
<section id="content-pane" class="row">
  <div class="col-md-12 text-justify content">
    

<h2 id="introduction">Introduction</h2>

<p>Together, Apache HTTP server, PHP, and MySQL form a powerful and popular combination for Web development.  Mac OS X (from 10.0 Cheetah to 10.11 El Capitan) and macOS (10.12 Sierra and above) are often shipped with pre-installed versions of Apache HTTP server and PHP but these are often outdated and merely customised for macOS. The well-known bundles <strong>*AMP</strong> (e.g. WAMP for Windows, LAMP for Linux, MAMP for Mac) are commonly used but also considered bloated or a bit of overkill for the beginners like me ;).</p>

<p>After few years of Java development, I turned myself in Web development, and in particular, PHP programming. As usual, I would start with pure PHP aspects that really help me to understand the fundamental concepts and techniques instead of being drown with everyone-known frameworks and their complexity and hard-to-understand magics.</p>

<p>As a result, I first looked for a simple setup of Apache and PHP that best suits the beginning of my initial learning path. In this note, I am writing down what I learn from the Internet and tweak them to my needs.</p>

<h2 id="goal-and-strategy">Goal and Strategy</h2>

<h3 id="goal">Goal</h3>

<blockquote>
<p>Let&rsquo;s assume that I want to set up an exemplary  Web development environment including Apache HTTP 2.4 server and PHP 7.</p>
</blockquote>

<h3 id="strategy">Strategy</h3>

<blockquote>
<p>A typical and well-documented approach is to load PHP as a module under Apache using the directive <code>LoadModule</code>. It is so-called <a href="http://www.php.net/manual/en/install.unix.apache2.php"><code>mod_php</code></a>. However, this approach is now gradually out of favor of Web developers and hosting providers because the tight combination of PHP and Apache makes things difficult for monitoring, debugging, and scaling. One of the recent favorite strategies is to set up PHP as Fast-CGI using <a href="http://php.net/manual/en/install.fpm.php">PHP-FPM</a> (FastCGI Process Manager). This way also brings several advantages including good support for nginx integration and <a href="https://wiki.apache.org/httpd/PHP-FPM">performance</a>.</p>
</blockquote>

<h3 id="actitivies">Actitivies</h3>

<blockquote>
<p>Based on the aforementioned analysis of strategies, I consider the following installation activities to fulfill my goal.
0. Installing <strong>Homebrew</strong> (package manager for macOS)
1. Installing <strong>Apache HTTP Server 2.4</strong>
2. Installing <strong>PHP 7</strong> and <strong>PHP-FPM</strong>
3. Putting <strong>Apache Server</strong> and <strong>PHP-FPM</strong> Together
4. (Optional) Installing <strong>DNSMasq</strong></p>
</blockquote>

<h2 id="installation">Installation</h2>

<h3 id="homebrew-https-brew-sh"><a href="https://brew.sh">Homebrew</a></h3>

<p><strong>Homebrew</strong> is currently a prominent and well-supported package managing solution for macOS. Installing <code>homebrew</code> is rather straightforward. Nevertheless, you must be familiar with using the command line in order to easily get thing done. All you need is to launch the Terminal app (<code>/Applications/Utilities/Terminal.app</code>) or even better the <a href="https://www.iterm2.com">iTerm2</a> and start executing terminal commands</p>

<blockquote>
<p>From now on, the sign <code>$</code> will denote the user&rsquo;s command line prompt where you will execute the terminal commands, except that you must not type <code>$</code>.</p>
</blockquote>

<p><strong>Homebrew</strong> requires Xcode&rsquo;s command line tooling so we must install it first.</p>

<pre><code class="language-sh"># Install Xcode command line tooling
$ xcode-select --install
</code></pre>

<p>Next we start installing <code>homebrew</code> using a <a href="https://brew.sh">one-line command</a>.</p>

<pre><code class="language-sh"># install homebrew
$ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;
</code></pre>

<p>By default, <code>homebrew</code> will be installed in the folder <code>/usr/local/Cellar</code> and use <code>/usr/local</code> and its sub-folders for the installed binary and configuration files. For more advanced settings and manual configurations, please refer <a href="https://docs.brew.sh/Installation.html">here</a>. To ensure that <code>homebrew</code> is properly installed, we can simply check.</p>

<pre><code class="language-sh">$ brew --version
Homebrew 1.3.8
Homebrew/homebrew-core (git revision 22ac3; last commit 2017-12-02)
</code></pre>

<p>The command <code>brew config</code>can show more information about the installed <code>homebrew</code>.</p>

<pre><code class="language-sh">$ brew config
</code></pre>

<p>Now we should add some extra <strong><em>taps</em></strong> (i.e. package repositories in <code>homebrew</code>&rsquo;s world) that contain packages we need, for instance, Apache HTTP server, PHP, and MySQL along with tools for running them as macOS services.</p>

<pre><code class="language-sh">$ brew tap homebrew/apache
$ brew tap homebrew/php
$ brew tap homebrew/services
</code></pre>

<p>After all, make sure <code>homebrew</code> is up-to-date.</p>

<pre><code class="language-sh">$ brew update
$ brew doctor
</code></pre>

<h3 id="apache-http-server-https-httpd-apache-org"><a href="https://httpd.apache.org">Apache HTTP Server</a></h3>

<h4 id="installing-apache-http-server-2-4">Installing Apache HTTP Server 2.4</h4>

<p>We can also use the pre-installed Apache HTTP server (from now on, Apache <code>httpd</code>, Apache, <code>httpd</code> will be used interchangeably) shipped with macOS. Nevertheless, I want to play around with the newer version. Apart from the <code>homebrew</code>-based installation commands, the steps for setting up <code>httpd</code> are the same in either way.</p>

<pre><code class="language-sh">$ brew install httpd
</code></pre>

<blockquote>
<p><strong>NOTE 1</strong>: Since Sep 30th, 2017 the Apache HTTP server package in <code>homebrew</code> has been renamed from <code>httpd24</code> to <code>httpd</code> and the corresponding folders are also changed from <code>apache2</code> to <code>httpd</code>. This note has been updated with the newer version. Apart from the aforementioned updates, the configuration steps remain intact though.</p>

<p><strong>NOTE 2</strong>: When we use <code>brew install &lt;package_name</code> without any further options, <code>homebrew</code>can accomplish the installation faster by downloading a <em>bottled version</em> (i.e. a <em>pre-compiled package</em>) from <a href="https://homebrew.bintray.com">homebrew.bintray.com</a>. If there are any options, it is often the case that <code>homebrew</code> will download the package source and compile from source. The compilation of a source package usually takes a a bit longer. For a simple and quick start, I mostly opt for the bottled versions of Apache server and PHP as the configured and compiled options are rather sufficient. After learning the fundamental aspects, I can turn to a more complex approach with lots of tweaking to suit my particular needs or experiments.</p>
</blockquote>

<p>By default, the <code>homebrew</code>-based Apache<code>httpd</code> will use the ports <code>8080</code> (<code>http</code>) and <code>8443</code> (<code>https</code>) that do not need system administrator privileges. In my setup, I will go with this option as I want to run Apache using my normal user account. Nonetheless, you can tell <code>homebrew</code> to install a version that use ports <code>80</code> and <code>443</code> using the option <code>--with-privileged-ports</code> as following. Other than that, we might just leave it for now and change it later in the configuration file at any time.</p>

<pre><code class="language-sh">$ brew install httpd --with-privileged-ports
</code></pre>

<p>In case you want to experiment with the most up-to-date <code>httpd</code> pulled from its development repository, use the option <code>--HEAD</code> along with other options. For example,</p>

<pre><code class="language-sh">$ brew install httpd --HEAD --with-privileged-ports
</code></pre>

<p>Let&rsquo;s assume the bottled <code>httpd</code> is installed. The Apache server will be installed in the following folder <code>/usr/local/Cellar/httpd/2.4.29</code> (or it may be different in your computer depending on your version of <code>homebrew</code> and Apache <code>httpd</code>). You can check the <code>homebrew</code>&rsquo;s Cellar, i.e. where <code>homebrew</code> puts installed packages, with <code>brew --cellar</code>. The precise location of <code>httpd</code> in a bit complex nerdy form is <code>$(brew --cellar)/httpd/$(brew list --versions httpd | cut -d ' ' -f 2)</code>.</p>

<pre><code class="language-sh">$ cd $(brew --cellar)/httpd/$(brew list --versions httpd | cut -d ' ' -f 2)
</code></pre>

<h4 id="configuring-apache-httpd">Configuring Apache <code>httpd</code></h4>

<h5 id="configuration-files">Configuration Files</h5>

<p>The main configuration file <code>httpd.conf</code> of <code>httpd</code> can be located at <code>/usr/local/etc/httpd</code>. There are some directives and options that you may want to notice or change ( <code>#</code>  starts a comment).</p>

<p>The default directive <code>Listen 8080</code> denotes where Apache server will be serving. You can change it to your favourite one or the one that suits your projects. Note that if you change to a port in the range from <code>1-1023</code> (so-called privileged ports), you need an administrator role to run the <code>httpd</code> process. Because I need to create virtual hosts for various projects, I have to configure <code>httpd</code> to listen at a particular address and port, which is <code>127.0.0.1:8080</code> in my setting.</p>

<p>The directives <code>LoadModule</code> will enable Apache HTTP modules in which some we need for configuring PHP-FPM as <code>mod_proxy</code>and <code>mod_proxy_fcgi</code> but are disabled by default.</p>

<pre><code class="language-apacheconf">Listen 127.0.0.1:8080
...
# LoadModule proxy_module libexec/mod_proxy.so
...
# LoadModule proxy_fcgi_module libexec/mod_proxy_fcgi.so
...
</code></pre>

<h5 id="starting-apache-server">Starting Apache server</h5>

<p>Apache <code>httpd</code> can be started by using either <code>apachectl start</code> or <code>brew services start httpd</code>. Note that the latter also installs a snippet to run Apache <code>httpd</code> as a macOs service so that <code>httpd</code> will start automatically when the computer starts or the user logs in.</p>

<pre><code class="language-sh">$ brew services start httpd
$ brew services list
</code></pre>

<h4 id="running-and-testing">Running and Testing</h4>

<p>We can use the following commands to start, stop, or restart <code>httpd</code>, respectively.</p>

<pre><code class="language-sh">$ brew services start httpd
$ brew services stop httpd
$ brew services restart httpd
</code></pre>

<p>We can check whether <code>httpd</code> will be running as a service.</p>

<pre><code class="language-sh">$ launchctl list | grep httpd
91962	0	homebrew.mxcl.httpd
</code></pre>

<p>Too see whether Apache <code>httpd</code> is up and running, you just start your Web browser and point to the URL <a href="http://localhost:8080"><code>http://localhost:8080</code></a> and should see a simple Web page say &ldquo;<strong>It works</strong>&rdquo;. Or you can also check in a more nerdy way, too.</p>

<pre><code class="language-sh">$ ps -ef | grep httpd
  501 91962     1   0  8:51AM ??         0:00.07 /usr/local/opt/httpd/bin/httpd -D FOREGROUND
  501 91968 91962   0  8:51AM ??         0:00.04 /usr/local/opt/httpd/bin/httpd -D FOREGROUND
  501 91969 91962   0  8:51AM ??         0:00.04 /usr/local/opt/httpd/bin/httpd -D FOREGROUND
  501 91970 91962   0  8:51AM ??         0:00.04 /usr/local/opt/httpd/bin/httpd -D FOREGROUND
$ lsof -Pni4 | grep httpd
httpd     91962 huytran    5u  IPv4 0xd51255ae3385c3d7      0t0  TCP *:* (CLOSED)
httpd     91968 huytran    5u  IPv4 0xd51255ae3385c3d7      0t0  TCP *:* (CLOSED)
httpd     91969 huytran    5u  IPv4 0xd51255ae3385c3d7      0t0  TCP *:* (CLOSED)
httpd     91970 huytran    5u  IPv4 0xd51255ae3385c3d7      0t0  TCP *:* (CLOSED)
</code></pre>

<p>To check whether Apache server configuration file is correct:</p>

<pre><code class="language-sh">$ apachectl configtest
Syntax OK
$ httpd -t
Syntax OK
</code></pre>

<h3 id="php-7-http-php-net"><a href="http://php.net">PHP 7</a></h3>

<h4 id="install-php-and-php-fpm">Install PHP and PHP-FPM</h4>

<p>Similar to Apache HTTP server, we can use <code>homebrew</code> to install newer/older versions of PHP ranging from 5.x to 7.x. The configuration steps are the same. I will go for the stable release of PHP 7.</p>

<pre><code class="language-sh">$ brew install php72
</code></pre>

<p>The  default installation of PHP 7 almost covers several useful aspects including a PHP module <code>libphp7.so</code> that can be integrated with Apache HTTP server via the directive <code>LoadModule</code> and <code>php-fpm</code> that can be used as FastCGI.</p>

<pre><code class="language-sh">$ php -version
PHP 7.2.0 (cli) (built: Dec  2 2017 11:27:08) ( NTS )
Copyright (c) 1997-2017 The PHP Group
Zend Engine v3.2.0, Copyright (c) 1998-2017 Zend Technologies
</code></pre>

<h4 id="php-configurations">PHP Configurations</h4>

<p>The main configuration file of PHP is <code>php.ini</code> as shown below.</p>

<pre><code class="language-sh">Configuration File (php.ini) Path: /usr/local/etc/php/7.2
Loaded Configuration File:         /usr/local/etc/php/7.2/php.ini
Scan for additional .ini files in: /usr/local/etc/php/7.2/conf.d
Additional .ini files parsed:      (none)
</code></pre>

<p>The default setting in <code>/usr/local/etc/php/7.2/php.ini</code> is quite sufficient for simple development purposes. We may tweak later if necessary but can leave it for now.</p>

<h4 id="starting-php-fpm">Starting PHP-FPM</h4>

<p>The configuration for PHP-FPM is <code>/usr/local/etc/php/7.2/php-fpm.conf</code>. Note the last lines in this file</p>

<pre><code class="language-ini">;include=/usr/local/etc/php/7.1/php-fpm.d/*.conf
</code></pre>

<p>You can remove the semi-colon to enable the inclusion of other configurations and/or might also change the path to whether it fits your development environment. In the folder <code>/usr/local/etc/php/7.1/php-fpm.d/*</code>, there is a file <code>www.conf</code> that can be used as a starting point for setting up your own PHP-FPM.</p>

<p>Now we can quickly start <code>php-fpm</code> to see whether something went wrong before doing some extra configuration steps.</p>

<pre><code class="language-sh">$ brew services start php72
==&gt; Successfully started `php72` (label: homebrew.mxcl.php72)
$ brew services stop php72
Stopping `php72`... (might take a while)
==&gt; Successfully stopped `php72` (label: homebrew.mxcl.php72)
$ brew services restart php72
</code></pre>

<p>Similar to the case of <code>httpd</code>, the command <code>brew services start php72</code> also copies the file <code>homebrew.mxcl.php72.plist</code> to the folder <code>~/Library/LaunchAgents</code> and sets it up as a macOS service.</p>

<pre><code class="language-sh">$ launchctl list | grep php
47728	0	homebrew.mxcl.php72
$ ps -ef | grep php-fpm
...
</code></pre>

<h3 id="putting-apache-server-and-php-fpm-together">Putting Apache Server and PHP-FPM Together</h3>

<p>After basically finishing the installation of Apache <code>httpd</code>, PHP 7 and <code>php-fpm</code>, we can start putting these pieces together.</p>

<h4 id="configurating-a-php-fpm-pool">Configurating a <code>php-fpm</code> pool</h4>

<p>PHP-FPM supports multiple resource <strong><em>pools</em></strong>. Each pool defines how <code>php-fpm</code> will create and manage processes. Let&rsquo;s start with enabling the inclusion and handling of pools in <code>/usr/local/etc/php/7.2/php-fpm.conf</code> by changing the following line</p>

<pre><code class="language-ini">;include=/usr/local/etc/php/7.2/php-fpm.d/*.conf
</code></pre>

<p>to (i.e. uncommenting it)</p>

<pre><code class="language-ini">include=/usr/local/etc/php/7.2/php-fpm.d/*.conf
</code></pre>

<p>Then we can leverage the stock configuration in <code>/usr/local/etc/php/7.2/php-fpm.d/www.conf</code>. In my case, I have cleaned up <code>www.conf</code> and kept a simple configuration as following for the sake of readability. The configuration explains for itself.</p>

<pre><code class="language-ini">[www]
user = _www
group = _www
listen = 127.0.0.1:9072
pm = dynamic
pm.max_children = 5
pm.start_servers = 2
pm.min_spare_servers = 1
pm.max_spare_servers = 3
</code></pre>

<p>The most important setting of each pool is the TCP socket (including IP address and port) or Unix domain socket that <code>php-fpm</code> will be listening on to receive FastCGI requests. This is configured using the directive <code>listten</code> . A typical setting of <code>php-fpm</code> is <code>listen = 127.0.0.1:9000</code>. As I might want to install multiple PHP versions for testing, I will change the port to <code>9072</code> that corresponds to the PHP version 7.2.</p>

<p>Note that we can also configure <code>php-fpm</code> to serve at a <a href="https://en.wikipedia.org/wiki/Unix_domain_socket">Unix domain socket</a> (UDS) because <code>php-fpm</code> and <code>httpd</code> processes are running in the same host. To do that, the directive <code>listen</code> must be changed, for example, <code>listen = /usr/local/var/run/php72-fpm.sock</code>. This approach would need extra effort to configure Apache (and <code>nginx</code>) to use PHP-FPM via UDS that we will visit later near the end of this guide.</p>

<p>Now as I want to check whether <code>php-fpm</code> will be up and running with the above changes, I restart <code>php-fpm</code> and check the open ports <code>9072</code>.</p>

<pre><code class="language-sh">$ brew services restart php72
$ ps -ef | grep php-fpm
...
$ lsof -Pni4 | grep php-fpm
php-fpm   53180 huytran    6u  IPv4 0xd51255ae2d4097b7      0t0  TCP 127.0.0.1:9072 (LISTEN)
php-fpm   53187 huytran    0u  IPv4 0xd51255ae2d4097b7      0t0  TCP 127.0.0.1:9072 (LISTEN)
php-fpm   53188 huytran    0u  IPv4 0xd51255ae2d4097b7      0t0  TCP 127.0.0.1:9072 (LISTEN)
</code></pre>

<h4 id="configuring-apache-to-handle-php-via-php-fpm">Configuring Apache to Handle PHP via PHP-FPM</h4>

<p>Apache <code>httpd</code> allows to define virtual hosts that suit my needs for separating different development projects. Instead of creating one large file <code>httpd.conf</code>, I will create a separate virtual host configuration. Again, I will start with the exemplary virtual host configuration provided in <code>/usr/local/etc/httpd/extra/httpd-vhosts.conf</code>.</p>

<h5 id="enabling-mod-proxy-and-mod-proxy-fcgi">Enabling <code>mod_proxy</code> and <code>mod_proxy_fcgi</code></h5>

<ul>
<li>Open the file <code>/usr/local/etc/httpd/httpd.conf</code>, change the following lines</li>
</ul>

<pre><code class="language-apacheconf"># LoadModule proxy_module libexec/mod_proxy.so
...
# LoadModule proxy_fcgi_module libexec/mod_proxy_fcgi.so
</code></pre>

<p>to</p>

<pre><code class="language-apacheconf">LoadModule proxy_module libexec/mod_proxy.so
...
LoadModule proxy_fcgi_module libexec/mod_proxy_fcgi.so
</code></pre>

<h5 id="defining-virtual-hosts">Defining Virtual Hosts</h5>

<p>I want to create different virtual hosts in my local computer for different development projects. For instance, a PHP development project resides in <code>/Users/huytran/working/dev/dev-web/php</code> and another project for HTML and Javascript in <code>/Users/huytran/working/dev/dev-web/htmljs</code>. Therefore, I will do the following steps.</p>

<ol>
<li>In <code>/usr/local/etc/httpd/httpd.conf</code>, change the following lines</li>
</ol>

<pre><code class="language-apacheconf">  #Include /usr/local/etc/httpd/extra/httpd-vhosts.conf
</code></pre>

<p>to</p>

<pre><code class="language-apacheconf">  Include /usr/local/etc/httpd/extra/httpd-vhosts.conf
</code></pre>

<ol>
<li>Then edit the file <code>/usr/local/etc/httpd/extra/httpd-vhosts.conf</code></li>
</ol>

<pre><code class="language-apacheconf">  &lt;VirtualHost *:8080&gt;
      ServerName php7.app
      DocumentRoot &quot;/Users/huytran/working/dev/dev-web/php&quot;
      ProxyPassMatch ^/(.*\.php(/.*)?)$ fcgi://127.0.0.1:9072/Users/huytran/working/dev/dev-web/php/$1
      DirectoryIndex index.php index.html
  	&lt;Directory &quot;/Users/huytran/working/dev/dev-web/php&quot;&gt;
  		Require all granted
  	&lt;/Directory&gt;
  &lt;/VirtualHost&gt;

  &lt;VirtualHost *:8080&gt;
      ServerName htmljs.dev
      DocumentRoot &quot;/Users/huytran/working/dev/dev-web/htmljs&quot;
  	&lt;Directory &quot;/Users/huytran/working/dev/dev-web/htmljs&quot;&gt;
  		Require all granted
  	&lt;/Directory&gt;
  &lt;/VirtualHost&gt;
</code></pre>

<p>Further information on Apache virtual hosts can be found <a href="https://httpd.apache.org/docs/current/vhosts">here</a> or <a href="https://httpd.apache.org/docs/current/vhosts/examples.html">here</a>. I can briefly explain some relevant directives used in my virtual host configuration:</p>

<ul>
<li><p><strong><em>&lt;VirtualHost&gt;</em></strong></p>

<ul>
<li><a href="https://httpd.apache.org/docs/current/mod/core.html#virtualhost"><code>&lt;VirtualHost&gt;</code></a> is used to define a new virtual host with respect to a specific hostname or IP address.</li>
<li>Syntax: <code>&lt;VirtualHost addr[:port] [addr[:port]] ...&gt; ... &lt;/VirtualHost&gt;</code></li>
<li>Here I use the wildcard <code>*:*</code> to match any IP addresses and ports. Note that the port specified in a <code>&lt;VirtualHost&gt;</code> does not affect the real port Apache     <code>httpd</code> is listening.</li>
</ul></li>

<li><p><strong><em>ServerName</em></strong></p>

<ul>
<li><a href="https://httpd.apache.org/docs/current/mod/core.html#servername"><code>ServerName</code></a> is recommended in each <code>&lt;VirtualHost&gt;</code> for resolution and matching. If absent, Apache will use the global <code>ServerName</code> stated in <code>httpd.conf</code>.</li>
<li>In my case, I assign different <code>ServerName</code>, <code>php7.test</code> and <code>htmljs.test</code>, respectively, for each project to distinguish them. As Apache mainly matches virtual hosts via IP addresses and it will resolve host names based on DNS servers, I will configure corresponding hostname resolution for <code>php7.test</code> and <code>htmljs.test</code> using <code>/etc/hosts</code> or <strong>DNSMasq</strong>.</li>
</ul></li>

<li><p><strong><em>DocumentRoot</em></strong></p>

<ul>
<li><a href="https://httpd.apache.org/docs/current/mod/core.html"><code>DocumentRoot</code></a> specifies the place where Apache <code>httpd</code> will look for files to serve relevant incoming request. In each case, <code>DocumentRoot</code> will be the absolute path of my development project.</li>
</ul></li>

<li><p><strong><em>ProxyPassMatch</em></strong></p>

<ul>
<li><a href="https://httpd.apache.org/docs/current/mod/mod_proxy.html#proxypassmatch"><code>ProxyPassMatch</code></a> is part of <code>mod_proxy</code> that can map remote servers into local URLs using regular expressions.</li>
<li>Syntax: <code>ProxyPassMatch [regex] !|url [key=value [key=value ...]]</code></li>
<li>When Apache <code>httpd</code> receives a request for a certain PHP file (e.g. <code>test.php</code>) then it needs PHP to handle that request. The regular expression <code>^/(.*\.php(/.*)?)$</code> is used to check whether the incoming request is for a <code>.php</code> file.</li>
<li><code>$1</code> is called back-reference, as it refers to the matched part of the regular expression corresponding to the outermost pair of parentheses. In case the expression matches the incoming request URI (i.e. the request corresponds to a file <code>.php</code>, for instance, <code>/test.php</code>) <code>$1</code> will represent the request URI. As a request is often treated as relative path from the <code>DocumentRoot</code>, we must add <code>DocumentRoot</code> path before <code>$1</code> to form an exact absolute path and hand it over to <code>php-fpm</code> by adding the prefix <code>fcgi://127.0.0.1:9072</code>. Note that <code>php-fpm</code> is serving at <a href="#configuring"><code>127.0.0.1:9072</code></a> and <code>fcgi://</code> denotes the scheme FastCGI provided by <code>mod_proxy_fcgi</code>.</li>
<li>The project <strong><em>htmljs.test</em></strong> does not need PHP processing, therefore I do not set the directive <code>ProxyPassMatch</code> there.</li>
</ul></li>

<li><p><strong><em>DirectoryIndex</em></strong></p>

<ul>
<li><a href="https://httpd.apache.org/docs/current/mod/mod_dir.html#directoryindex"><code>DirectoryIndex</code></a> sets the list of resources for an indexing request. As I want to use PHP, I set <code>index.php</code> as index resource backed up by the default <code>index.html</code>. Note that <code>DirectoryIndex</code> can also be set globally in <code>httpd.conf</code> that affects the main server and can be inherited in all virtual hosts.</li>
</ul>

<pre><code class="language-apacheconf">&lt;IfModule dir_module&gt;
    DirectoryIndex index.php index.html
&lt;/IfModule&gt;
</code></pre>

<ul>
<li>Note that <code>DirectoryIndex index.html</code> is the default global option defined in <code>httpd.conf</code>, I do not need to repeat for the virtual host <code>htmljs.test</code>.</li>
</ul></li>

<li><p><strong><em>&lt;Directory&gt;</em></strong></p>

<ul>
<li><a href="https://httpd.apache.org/docs/current/mod/core.html#directory"><code>&lt;Directory&gt;</code></a> encloses the settings for folders, subfolders, and their contents.</li>
<li><a href="https://httpd.apache.org/docs/current/mod/mod_authz_core.html#require"><code>Require all granted</code></a> : access is allowed unconditionally (authorization <code>mod_authz_core</code>). We need this, otherwise Apache will return an error <code>403 Forbidden</code>.</li>
</ul></li>
</ul>

<h4 id="hostname-resolution">Hostname Resolution</h4>

<p>As mentioned before, I will use the virtual hosts <code>php7.test</code> and <code>htmljs.test</code> in my macOS to refer to my corresponding Web development projects. These hostnames are not known by Apache <code>httpd</code>. Thus, I must tell <code>httpd</code> how to resolve these hostnames. In my setting, all virtual hosts are sharing in the same local computer with the well-known local IP address <code>127.0.0.1</code>. A simple  solution is to change the file <code>/etc/hosts</code> where macOS will look for when resolving hostnames. This solution requires sufficient administration privilege.</p>

<pre><code class="language-sh">$ sudo open -e /etc/hosts
Password: (enter your password here)
</code></pre>

<p>After entering the administrator password, I will add two following lines to <code>/etc/hosts</code>.</p>

<pre><code>127.0.0.1    php7.test
127.0.0.1    htmljs.test

</code></pre>

<p>In case either you do not want to mess up system files like <code>/etc/hosts</code> or you have several development projects, you can leverage <code>dnsmasq</code> for automatically resolving hostnames with very simple configurations. Note that this is also the reason I chose the <code>.test</code> for all of my development projects such that I can use <code>dnsmasq</code> and only <strong>one line directive</strong> to resolve the TLD (Top-Level Domain) <code>app</code>. You can surely pick any TLD other than <code>app</code> .</p>

<h4 id="testing-apache-and-php">Testing Apache and PHP</h4>

<p>Apart from the aforementioned tests, we can also check whether the integration of Apache <code>httpd</code> and <code>php-fpm</code> is successful.</p>

<h5 id="creating-testing-files">Creating Testing Files</h5>

<p>Let&rsquo;s create a file <code>index.php</code> in <code>/Users/huytran/working/dev/dev-web/php</code></p>

<pre><code class="language-php">&lt;?php 
  echo 'PHP Development Project';
</code></pre>

<p>and a file <code>index.html</code> in <code>/Users/huytran/working/dev/dev-web/htmljs</code></p>

<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;body&gt;
	&lt;h1&gt;HTML and Javascript Project&lt;/h1&gt;	
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h5 id="restart-servers">Restart Servers</h5>

<p>After changing any configuration of Apache and PHP, we must restart <code>httpd</code> and <code>php-fpm</code> to embrace these changes.</p>

<pre><code class="language-sh">$ brew services restart httpd
$ brew services restart php72
</code></pre>

<p>Given no problems so far, the servers will be successully restarted. Then use your Web browser to open the following URLs <a href="http://php7.test:8080"><code>http://php7.test:8080</code></a> and <a href="http://htmljs.dev:8080"><code>http://htmljs.test:8080</code></a>. You should see the contents created above should everything is correctly configured.</p>

<h3 id="dnsmasq-http-www-thekelleys-org-uk-dnsmasq-doc-html"><a href="http://www.thekelleys.org.uk/dnsmasq/doc.html">DNSMasq</a></h3>

<p>Instead of altering system hosts <code>/etc/hosts</code>, I can make use of <code>dnsmasq</code> to resolve hostnames specified in Apache virtual hosts.</p>

<h4 id="installing-dnsmasq">Installing DNSMasq</h4>

<pre><code class="language-sh"># update homebrew and install dnsmasq 
$ brew update &amp;&amp; brew install dnsmasq
# Copy the dnsmasq daemon configuration file to be loaded at system startup time
$ sudo cp $(brew list dnsmasq | grep /homebrew.mxcl.dnsmasq.plist$) /Library/LaunchDaemons/
# start dnsmasq
$ sudo launchctl load -w /Library/LaunchDaemons/homebrew.mxcl.dnsmasq.plist
</code></pre>

<h4 id="configuring-dnsmasq">Configuring DNSMasq</h4>

<p>After installing <code>dnsmasq</code>,  open the configuration file</p>

<pre><code class="language-sh">$ open -e /usr/local/etc/dnsmasq.conf
</code></pre>

<p>add the following line at the end and save the file.</p>

<pre><code>address=/app/127.0.0.1
</code></pre>

<p>The above configuration line tells <code>dnsmasq</code> to resolve the TLD <code>dev</code> to the local IP address <code>127.0.0.1</code>. You can now use any hostnames like <code>this.is.a.development.project.test</code> in Apache virtual hosts.</p>

<h4 id="configuring-macos-to-use-dnsmasq">Configuring macOS to use DNSMasq</h4>

<p>We have to tell macOS that <code>dnsmasq</code> is now a nameserver running at the local host. The configuration file is <code>/etc/resolv.conf</code> specifies the nameservers for looking up hostnames. On the one hand, we should not mess up the system setting. Moreover, macOS might overwrite <code>/etc/resolv.conf</code> when there are changes in Network setting. An elegant solution is to create a file in the folder <code>/etc/resolver/</code>with the exact TLD managed by <code>dnsmasq</code>.</p>

<pre><code class="language-sh">$ sudo mkdir -p /etc/resolver/
$ sudo sh -c 'echo &quot;nameserver 127.0.0.1&quot; &gt; /etc/resolver/app'
</code></pre>

<p>The aforementioned commands needs administrator privileges and will create a file <code>app</code> with the content <code>nameserver 127.0.0.1</code> in the folder <code>/etc/resolver/</code>.</p>

<h4 id="testing-dnsmasq">Testing DNSMasq</h4>

<p>Now we can delete the lines added before in <code>/etc/hosts</code> and start <code>dnsmasq</code> (as <code>root</code>) and test the resolving of hostnames.</p>

<pre><code class="language-sh"># start dnsmasq
$ sudo brew services start dnsmasq

# ping the hostnames
$ ping -c 1 php7.app
PING php7.app (127.0.0.1): 56 data bytes
64 bytes from 127.0.0.1: icmp_seq=0 ttl=64 time=0.040 ms

$ ping -c 1 htmljs.app
PING htmljs.app (127.0.0.1): 56 data bytes
64 bytes from 127.0.0.1: icmp_seq=0 ttl=64 time=0.039 ms

# query hostname using dnsmasq running at 127.0.0.1
$ dig php7.app @127.0.0.1
...
;; ANSWER SECTION:
php7.app.		0	IN	A	127.0.0.1

$ dig htmljs.app @127.0.0.1
...
;; ANSWER SECTION:
htmljs.app.		0	IN	A	127.0.0.1

# test arbitrary hostnames ending with .app
$ dig an.arbitrary.host.app @127.0.0.1
</code></pre>

<h2 id="extra-tips">Extra Tips</h2>

<h3 id="using-proxy-fastcgi-via-handler">Using Proxy FastCGI via Handler</h3>

<p>Instead of configuring <code>ProxyPassMatch</code> for each individual virtual host to handle <code>.php</code> files, we can also set up directives in Apache <code>httpd.conf</code> (global scope) or at the beginning of the virtual host configuration <code>localhost.conf</code> (virtual host scope) via handlers.</p>

<ol>
<li>First comment out or delete the line <code>ProxyPassMatch ...</code> in the virtual host configuration <code>/usr/local/etc/httpd/extra/httpd-vhosts.conf</code>.</li>
</ol>

<pre><code class="language-apacheconf">   # ProxyPassMatch ^/(.*\.php(/.*)?)$ fcgi://127.0.0.1:9072/Users/huytran/working/dev/dev-web/php/$1
</code></pre>

<ol>
<li>Then, add the following lines to either the end of  <code>/usr/local/etc/httpd/httpd.conf</code> or the beginning of <code>/usr/local/etc/httpd/extra/httpd-vhosts.conf</code>.</li>
</ol>

<pre><code class="language-apacheconf">  &lt;Proxy &quot;fcgi://localhost:9072/&quot; enablereuse=on max=10&gt;
  &lt;/Proxy&gt;
  &lt;FilesMatch &quot;\.php$&quot;&gt;
      &lt;If &quot;-f %{REQUEST_FILENAME}&quot;&gt;
          SetHandler &quot;proxy:fcgi://127.0.0.1:9072/&quot;
      &lt;/If&gt;
  &lt;/FilesMatch&gt;
</code></pre>

<ul>
<li><a href="https://httpd.apache.org/docs/current/mod/core.html#filesmatch"><code>&lt;FilesMatch&gt;</code></a> : defines the scope of the enclosed directives by filenames that match the regular expression.

<ul>
<li><em>Syntax</em>: <code>&lt;FilesMatch regex&gt; ... &lt;/FilesMatch&gt;</code></li>
</ul></li>
<li><a href="https://httpd.apache.org/docs/current/mod/core.html#sethandler"><code>SetHandler</code></a>: forces matching files to be processed by a handler.

<ul>
<li><em>Syntax</em>: <code>SetHandler handler-name|none|expression</code></li>
</ul></li>
</ul>

<ol>
<li>Restart <code>httpd</code></li>
</ol>

<h3 id="handling-php-via-unix-domain-sockets">Handling PHP via Unix Domain Sockets</h3>

<p>As mentioned before, PHP-FPM can serve on <strong>Unix domain sockets (UDS)</strong>, too. UDS is widely used in the Unix/Linux world for inter-process communication. To enable PHP-FPM listening on UDS, open file <code>/usr/local/etc/php/7.1/php-fpm.d/www.conf</code> and change the <code>listen</code> directive as following.</p>

<pre><code class="language-ini">[www]
...
listen = /usr/local/var/run/php72-fpm.sock
...
</code></pre>

<p>Now we must change the Apache configuration to adapt to UDS as well. In case we use <code>ProxyPassMatch</code> directive, change it like this:</p>

<pre><code class="language-apacheconf">ProxyPassMatch ^/(.*\.php(/.*)?)$ unix:/usr/local/var/run/php72-fpm.sock|fcgi://127.0.0.1:9072/Users/huytran/working/dev/dev-web/php
</code></pre>

<p>The change is to add <code>unix:/usr/local/var/run/php72-fpm.sock|</code> before <code>fcgi://...</code> and remove the captured request URI <code>/$1</code> at the end.</p>

<p>Similarly, if we switch to Apache handler as above, we update the Apache configuration accordingly.</p>

<pre><code class="language-apacheconf">&lt;Proxy &quot;unix:/usr/local/var/run/php72-fpm.sock|fcgi://localhost:9072/&quot; enablereuse=on max=10&gt;
&lt;/Proxy&gt;
&lt;FilesMatch &quot;\.php$&quot;&gt;
    &lt;If &quot;-f %{REQUEST_FILENAME}&quot;&gt;
        SetHandler &quot;proxy:unix:/usr/local/var/run/php72-fpm.sock|fcgi://127.0.0.1:9072/&quot;
    &lt;/If&gt;
&lt;/FilesMatch&gt;
</code></pre>

<p>We should ensure the configurations are good and then restart the servers afterwards.</p>

<pre><code class="language-sh"># check Apache config
$ apachectl -t
Syntax OK
# check php-fpm config
$ php-fpm -t
[30-Sep-2017 19:39:46] NOTICE: configuration file /usr/local/etc/php/7.2/php-fpm.conf test is successful
# restart servers
$ brew services restart httpd
$ brew services restart php72
</code></pre>

  </div>
</section>
<section id="tag-pane" class="row meta">
  
  <div class="col-md-12">
    <h6 class="text-right meta">
      
      
      
      TAGS:
      
      
      <a class="meta" href="/tags/dnsmasq">DNSMASQ</a>, 
      
      <a class="meta" href="/tags/httpd">HTTPD</a>, 
      
      <a class="meta" href="/tags/macos">MACOS</a>, 
      
      <a class="meta" href="/tags/php">PHP</a>, 
      
      <a class="meta" href="/tags/server">SERVER</a>
      
      
      
    </h6>
  </div>
  
</section>








<section id="menu-pane" class="row menu text-center">
  
  
  <span><a class="menu-item" href="/blog/xung-ho/">&lt; prev | </a></span>
  
  
  <span><a class="menu-item" href="/blog">blog</a></span>
  
  
  
  <h4 class="text-center"><a class="menu-item" href="/">home</a></h4>
</section>



<footer class="row text-center footer">
  <hr />
  
  <h6 class="text-center copyright">© 2018. Huy Tran. <a href="http://creativecommons.org/licenses/by/3.0/">Some Rights Reserved</a>.</h6>
  
  <h6 class="text-center powered">Powered by <a href="https://gohugo.io/">Hugo</a> &amp; <a href="https://github.com/shenoybr/hugo-goa">Goa</a>.</h6>
  
  
</footer>

</div>



<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  

<script type="text/javascript">
hljs.initHighlightingOnLoad();
</script>




<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
<script src="js/main.js"></script>
</body>
</html>


