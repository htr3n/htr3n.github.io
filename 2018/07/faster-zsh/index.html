<!DOCTYPE html><html lang="en"><head><link href="http://gmpg.org/xfn/11" rel="profile"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta http-equiv="Cache-Control" content="public"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="generator" content="Hugo 0.45.1"><title>Faster and enjoyable ZSH (maybe) • htr3n&#39;s</title><meta name="description" content="htr3n&#39;s blog :: technology, thoughts, opinions, and rants"><meta name="keywords" content="blog,java,php,python,golang,javascript,shell,thoughts,macos,apple,tiếng việt,parental,family,apache,httpd,laravel,politics,critical thinking,chính trị,luật,hiến pháp,xã hội,gia đình"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Faster and enjoyable ZSH (maybe)"><meta name="twitter:description" content="Z shell (Zsh) has been my shell of choice in both Linux and macOS. I used to install oh-my-zsh or the claimed-to-be-faster Prezto or Zim to leverage some of their cool libraries. And I have just realised that my favourite terminal app, iTerm 2, becomes more and more sluggish when loading a new tab or window with more than one and a half second (without some virtual environment loaders like nvm, rvm, rbenv, jenv).

"><meta property="og:title" content="Faster and enjoyable ZSH (maybe)"><meta property="og:description" content="Z shell (Zsh) has been my shell of choice in both Linux and macOS. I used to install oh-my-zsh or the claimed-to-be-faster Prezto or Zim to leverage some of their cool libraries. And I have just realised that my favourite terminal app, iTerm 2, becomes more and more sluggish when loading a new tab or window with more than one and a half second (without some virtual environment loaders like nvm, rvm, rbenv, jenv).

"><meta property="og:type" content="article"><meta property="og:url" content="https://htr3n.github.io/2018/07/faster-zsh/"><meta property="og:image" content="https://htr3n.github.io/2018/07/faster-zsh/iterm2-login.png"><meta property="og:image" content="https://htr3n.github.io/2018/07/faster-zsh/shell-startup-actual.png"><meta property="og:image" content="https://htr3n.github.io/2018/07/faster-zsh/terminal-login.png"><span style="color:red">&#34;img/avatar.png&#34;<br></span><meta property="article:published_time" content="2018-07-23T00:00:00&#43;00:00"><meta property="article:modified_time" content="2018-07-27T00:00:00&#43;00:00"><link rel="stylesheet" href="https://htr3n.github.io//css/hyde-hyde.css"><link rel="stylesheet" href="https://htr3n.github.io//css/print.min.css" media="print"><!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries --><!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]--><!-- Icons --><link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png"><link rel="shortcut icon" href="/favicon.png"></head><body><div class="sidebar"><div class="container"><div class="sidebar-about"><span class="site__title"><a href="https://htr3n.github.io/">htr3n&#39;s</a></span><div class="author-image"><img src="https://htr3n.github.io/img/avatar.png" alt="Author Image" class="img--circle img--headshot element--center"></div><p class="site__description">technology, thoughts, opinions, rants</p></div><div><ul class="sidebar-nav"><li><a href="/posts/"><span>Posts</span></a></li><li><a href="/portfolio/"><span>Portfolio</span></a></li><li><a href="/vn/"><span>Tiếng Việt</span></a></li><li><a href="/about/"><span>About</span></a></li></ul></div><p><section class="social"><a href="https://twitter.com/htr3n"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a> &nbsp;<a href="https://github.com/htr3n"><i class="fab fa-github fa-lg" aria-hidden="true"></i></a> &nbsp;<a href="https://linkedin.com/in/htr3n"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a> &nbsp;<a href="https://stackoverflow.com/users/339302"><i class="fab fa-stack-overflow fa-lg" aria-hidden="true"></i></a> &nbsp;<a href="https://keybase.io/htr3n"><i class="fab fa-keybase fa-lg" aria-hidden="true"></i></a> &nbsp;<a href="mailto:hoang.huy.tran&#43;blog@gmail.com"><i class="fas fa-at fa-lg" aria-hidden="true"></i></a></section></p><p class="copyright">&copy; 2018 htr3n. <a href="https://creativecommons.org/licenses/by-sa/4.0">Some Rights Reserved</a>.<br>Built with <a href="https://gohugo.io">Hugo</a> ❤️ <a href="https://github.com/htr3n/hyde-hyde">hyde-hyde</a>.</p></div><div></div></div><div class="content container"><article><header><h1>Faster and enjoyable ZSH (maybe)</h1><div class="post__meta"><i class="fas fa-calendar-alt"></i> Jul 23, 2018 in <a class="post__category" href="/categories/dev">DEV</a> • <a class="post__category" href="/categories/system">SYSTEM</a><br><i class="fas fa-tags"></i> <a class="post__tag" href="/tags/zsh">zsh</a> <a class="post__tag" href="/tags/shell">shell</a> <a class="post__tag" href="/tags/macos">macos</a> <a class="post__tag" href="/tags/performance">performance</a><br><i class="fas fa-clock"></i> 14 min read</div></header><div class="post"><p>Z shell (Zsh) has been my shell of choice in both Linux and macOS. I used to install <a href="https://github.com/robbyrussell/oh-my-zsh">oh-my-zsh</a> or the claimed-to-be-faster <a href="https://github.com/sorin-ionescu/prezto">Prezto</a> or <a href="https://github.com/zimfw/zimfw">Zim</a> to leverage some of their cool libraries. And I have just realised that my favourite terminal app, <a href="https://www.iterm2.com">iTerm 2</a>, becomes more and more sluggish when loading a new tab or window with more than one and a half second (without some virtual environment loaders like <a href="https://github.com/creationix/nvm">nvm</a>, <a href="https://rvm.io/">rvm</a>, <a href="https://github.com/rbenv/rbenv">rbenv</a>, <a href="http://www.jenv.be">jenv</a>).</p><p></p><p>A quick <a href="https://www.google.com/search?q=faster+zsh"><em>G-fu</em></a> could yield numerous posts on how to debug, optimise, speed up Zsh. I spent some time to refactore my own lightweight scripts instead of using big frameworks and was able to reach nearly one third of a second. In this post, I will share and discuss some aspects that might affect Zsh loading time and how to mitigate them. Most of the relevant code and configurations can be found <a href="https://github.com/htr3n/zsh-config">here</a>.</p><blockquote><p><strong>TL;DR:</strong><br>There are many aspects in Zsh that can potentially slow down its startup time and can be mitigated.</p><ul><li><a href="#organising-shell-startup-order">Organising shell startup order</a></li><li><a href="#avoiding-creating-subprocesses">Avoiding creating subprocesses</a></li><li><a href="#lazy-loading">Lazy-loading instead of eager-loading</a></li><li><a href="#optimising-completion-system">Optimising completion system</a></li><li><a href="#optimising-shell-prompts">Optimising shell prompts</a></li><li><a href="#macos-optimisations">MacOS-specific optimisations</a></li></ul></blockquote><h2 id="performance-analysis">Performance Analysis</h2><h4 id="overall-execution-time">Overall execution time</h4><p>Crunching some numbers on Zsh loading time would be definitely useful for further in depth analysis of its performance. A simple timing of Zsh startup time can be measured approximately using the <code>time</code> command that is available in most Unix/Linux/Mac systems.</p><pre><code class="language-sh">$ /usr/bin/time /bin/zsh -i -c exit
        0.67 real         0.41 user         0.26 sys
</code></pre><p>The output of the command shows the execution time of Zsh breaking down to user-land and system. In order to get a better approximation, we can make a loop that invokes <code>time</code> for 10 or greater, if possible.</p><pre><code class="language-sh">$ for i in $(seq 1 10); do /usr/bin/time /bin/zsh -i -c exit; done;
</code></pre><p>This timing method is very fast and handy in case you want to quickly see how your Zsh performs, especially to test some changes you have just made.</p><h4 id="profiling">Profiling</h4><p>Zsh provides a built-in module <a href="http://zsh.sourceforge.net/Doc/Release/Zsh-Modules.html#The-zsh_002fzprof-Module"><code>zsh/zprof</code></a> that can be used to profile Zsh functions. At the beginning of <code>~/.zshrc</code>, we add <code>zmodload zsh/zprof</code>. After restart the shell, we can use the command <code>zprof</code> to show a very rich output on Zsh startup loading. An illustrative output of <code>zprof</code> is shown below.</p><pre><code class="language-sh">$ zprof
num  calls                time                       self            name
------------------------------------------------------------------------------
 1)    1          51.31    51.31   22.68%     49.68    49.68   21.96%  zle-line-init
 2)    2          45.72    22.86   20.21%     45.72    22.86   20.21%  compaudit
 3)  195          34.71     0.18   15.34%     25.52     0.13   11.28%  _zsh_autosuggest_bind_widget
 ...
</code></pre><blockquote><p><strong>Note</strong></p><p>Two aforementioned approaches can give us a rough analysis on what aspects are invoked during Zsh startup so that we might figure out the bottleneck. In case you need to dig deeper, Arnout wrote <a href="http://blog.xebia.com/profiling-zsh-shell-scripts">a nice article</a> in which he suggested a in-depth analysis and visualisation of Zsh loading using <code>xtrace</code> and <code>kcachegrind</code>. Benjamin developed <a href="https://esham.io/2018/02/zsh-profiling">a similar approach</a> to more thorough tracing and analysis Zsh execution.</p></blockquote><h2 id="problematic-aspects-and-mitigation">Problematic Aspects and Mitigation</h2><p>Using two simple methods mentioned above, I was able to roughly understand some issues of my Zsh settings and tried to mitigate them to reduce startup time. I could not report the exact steps what have been done as it was a lot of trial-and-errors. Here I will discuss some major aspects combining my actual experiment and G-fu research.</p><h3 id="organising-shell-startup-order">Organising shell startup order</h3><p>The order that Zsh loads its configuration files are documented <a href="http://zsh.sourceforge.net/Intro/intro_3.html">here</a> and <a href="http://zsh.sourceforge.net/Doc/Release/Files.html">here</a>. Peter Ward <a href="https://blog.flowblok.id.au/2013-02/shell-startup-scripts.html">drew a nice diagram</a> showing the loading process of Zsh alongside with Bash and Sh (note that he omitted the system-wide configurations in Zsh part).</p><figure><img src="https://htr3n.github.io/2018/07/faster-zsh/shell-startup-actual.png" alt="Shell startup order" style="max-width: 100%;"><figcaption><span class="img--caption">Figure 1. Bash, sh, and zsh shells startup order [<a href="https://blog.flowblok.id.au/2013-02/shell-startup-scripts.html">source</a>]</span></figcaption></figure><p>It&rsquo;s also useful to understand relevant shell concepts, such as <em>login</em> vs. <em>non-login</em>, <em>interactive</em> vs. <em>non-interactive</em> shown in the diagram. Please refer to, for example, <a href="https://askubuntu.com/a/438170/115425">here</a> or <a href="https://askubuntu.com/a/879400/115425">here</a> for further explanations.</p><blockquote><p><strong>Some shell examples:</strong></p><ul><li>when opening a terminal emulator app (e.g. Terminal or iTerm 2), we are creating an <em>interactive, non-login shell</em> (please see <code>login -pf</code> later).</li><li>when logging in into a machine using command line <a href="https://en.wikipedia.org/wiki/Secure_Shell"><code>ssh</code></a> or <a href="https://en.wikipedia.org/wiki/Su_%28Unix%29"><code>su - username</code></a>, we are working with an <em>interactive login</em> shell.</li><li>when executing a shell script, it is on a <em>non-interactive</em>, <em>non-login</em> shell.</li></ul></blockquote><p>Grokking Zsh startup order will help us putting relevant configurations in right files as well as optimising the loading process. My local Zsh setting is orgranised as follow:</p><ul><li><code>.zshenv</code>: invoked by all invocations of Zsh, so we should keep it small and merely initialise necessary variables.</li><li><code>.zlogin</code>: will be loaded in login shells after <em>.zshrc</em>. My <a href="https://github.com/htr3n/zsh-config/blob/master/zlogin"><em>.zlogin</em></a> will compile <code>zcompdump</code> in background as this is time-consuming and done only once per log-in session.</li><li><code>.zprofile</code> : similar to <em>.zlogin</em> but will be sourced before <em>.zshrc</em>. Note that, both <em>.zprofile</em> and <em>.zshrc</em> are skipped in non-login non-interactive shells, as shown in Figure 1. So I learned a trick from <a href="https://github.com/sorin-ionescu/prezto/tree/master/runcoms">Prezto</a> that declares environment variables in <em>.zprofile</em> and uses <em>.zshenv</em> to source <em>.zprofile</em> (e.g. <a href="https://github.com/htr3n/zsh-config/blob/master/zprofile"><em>.zprofile</em></a> and <a href="https://github.com/htr3n/zsh-config/blob/master/zshenv"><em>.zshenv</em></a>). Tnis way, non-login non-interactive shells will receive proper variable initialisations.</li><li><code>.zshrc</code>: will be sourced in interactive shells. This contains the main part of Zsh configuration (e.g. my <a href="https://github.com/htr3n/zsh-config/blob/master/zshrc"><em>.zshrc</em></a>).</li></ul><h3 id="avoiding-creating-subprocesses">Avoiding creating subprocesses</h3><p>Some commands look totally innocent and standard in your shell scripts but might cost you dearly. Among them are commands that launch new <a href="http://tldp.org/LDP/abs/html/othertypesv.html#CHILDREF2">child processes</a> such as <a href="http://zsh.sourceforge.net/Doc/Release/Expansion.html#Command-Substitution"><em>command substitutions</em></a> and <a href="https://www.unix.com/man-page/posix/1posix/eval"><em>eval</em> commands</a>.</p><h5 id="command-substitutions">Command Substitutions</h5><p>In Zsh, a command enclosed in <code>$(command)</code> or quoted with backticks <code>`command`</code> will be replaced with its standard output. Thus, it is very popular in Unix/Linux world when one wants to execute a command and get the output to process further on. The bad thing is that <em>command substitution</em> will launch a new process (i.e. a <a href="http://tldp.org/LDP/abs/html/subshells.html#SUBSHELLSREF">subshell</a>).</p><h5 id="eval-command"><code>eval</code> command</h5><pre><code class="language-sh">eval [arg...]
</code></pre><p>The command <code>eval</code> (sounds with <em>evil</em>, ^_O) is part of POSIX standard and is available in most shells. It&rsquo;s often used together with <em>command substitution</em>. Essentially, <code>eval</code> concats its arguments separated with spaces along with evaluating any variables or expressions to form a command with or without arguments. Then it executes the resulting command in the current shell. As such, <code>eval</code> will cause side-effects as it must evaluate the inputs and perform expansions, if any.</p><pre><code class="language-sh">$ command=&quot;print 'Hello World'&quot;
$ command			   # nothing happen
$ eval $command
Hello World
</code></pre><p>This feature makes <code>eval</code> powerful as it can dynamically evaluate and execute code. But dynamic evaluation also makes <code>eval</code> risky and time-consuming.</p><p>In some cases, for instance, simple string manipulation, we can consider to replace command substitutions and <code>eval</code> commands that invoke <code>sed</code>, <code>awk</code>, etc., with Zsh built-in constructs or hard-coded constants. Zsh provides numerous powerful built-in mechanisms for substring matchings, string explosion/splitting, and <a href="http://zsh.sourceforge.net/Doc/Release/Expansion.html">expansions</a>.</p><p>For instance, when using <a href="https://brew.sh">Homebrew</a>, it is very convenient to get the path to an installed package using <code>$(brew --prefix &lt;package&gt;)</code>.</p><pre><code class="language-sh">export PATH=$PATH:&quot;$(brew --prefix httpd)/bin&quot;
</code></pre><p>It turns out many calls to <code>$(brew --prefix ...)</code> would launch many subprocesses and thus <a href="https://kev.inburke.com/kevin/profiling-zsh-startup-time">slow down Zsh notably</a>. When replacing that <code>$()</code> command with its actual output, I could gain certain improvement. The caveat is that some upgraded versions might break these hard-coded values.</p><h3 id="lazy-loading"><em>Lazy-loading</em> instead of <em>eager-loading</em></h3><h5 id="function-autoloading">Function autoloading</h5><p>We can define and source new functions in Zsh. In this way, a function is <em>eagerly loaded</em> and always available for use. Note that most of these functions might be not really needed until being invoked.</p><p>Zsh can help postponing their loading time and allow to <em>load-on-demand</em> via <a href="http://zsh.sourceforge.net/Doc/Release/Functions.html#Autoloading-Functions">function autoloading</a>. This technique is often called <em>lazy loading</em>. Performance-wise, <em>lazy loading</em> will put less pressure to the underlying system and reduce memory footprint. The same techniques are also preferred in many other fields such as databases, dynamic runtime libraries, etc.</p><p>In my codebase, I create a folder, namely, <code>autoloaded</code>, to store functions that will be, er&hellip;, autoloaded by Zsh. For each function, for instance, <code>function hello(){...}</code>, I will create a corresponding file named <code>hello</code> inside <code>autoloaded</code>. The content of that file is the function body (i.e. without <code>function</code> and <code>(){}</code>).</p><pre><code class="language-sh">$ mkdir autoloaded
$ echo &quot;print 'Hello World'&quot; &gt;&gt; autoloaded/hello
$ tree
.
└── autoloaded
    └── hello
</code></pre><p>The folder <code>autoloaded</code> must be added to ZSH variable <code>fpath</code> where ZSH will look for function definitions.</p><pre><code class="language-zsh"># add 'autoload' to fpath
$ fpath=($fpath autoloaded)
# try to invoke 'hello'
$ hello
zsh: command not found: hello
# now mark `hello` for autoloading.
$ autoload hello
# quickly check how `hello` will be loaded.
$ which hello
hello () {
	# undefined
	builtin autoload -X
}
# now it works fine
$ hello
Hello World
</code></pre><p>The body of <code>hello</code> was marked with <code>#undefined</code> along with <code>builtin autoload -X</code> meaning it will be loaded on-demand. The first time <code>hello</code> is called, Zsh will automatically load and execute it.</p><p>In the same way, I configured Zsh to load all of my functions on-demand to reduce memory and loading time.</p><blockquote><p><strong>Note</strong>:<br>In <a href="https://github.com/htr3n/zsh-config">my scripts</a>, <code>autoload -Uz function_name</code> was used. The option <code>-U</code> prevents alias from being expanded. That is, whenever you define an alias and a function having the same name, the alias will be considered first instead, so <code>-U</code> just skips alias expansion. And the option <code>-z</code> indicates that the function will be auto-loaded using <code>zsh</code> or <code>ksh</code> style.</p></blockquote><h5 id="loading-virtual-environments">Selective- or lazy-loading virtual environments</h5><p>Many virtual environment loaders like <a href="https://rvm.io/">rvm</a>, <a href="https://github.com/rbenv/rbenv">rbenv</a>, <a href="http://www.jenv.be">jenv</a>, <a href="https://github.com/creationix/nvm">nvm</a> have been developed to manage different run-time versions and libraries. While being very handy for software development, most of these tools need to be <em>eagerly loaded</em> (e.g. directly <code>source</code> in <code>.zshrc</code>) to work properly.</p><p>Instead, we can consider to transform these loaders as much as possible into <em>on-demand</em> wrapper functions. You can find a good example <a href="https://peterlyons.com/problog/2018/01/zsh-lazy-loading">here</a>. In summary, Peter&rsquo;s trick is to override <code>nvm</code> with his own autoloaded <code>nvm()</code> (that eventually invokes the original <code>nvm</code> loader). Carlos also went to same way for <code>rbenv</code>, his own <code>antibody</code>, <code>pyenv</code> and achieved <a href="https://carlosbecker.com/posts/speeding-up-zsh">some good results</a>. Benny C. Wong <a href="http://bennycwong.github.io/post/speeding-up-oh-my-zsh/">did similarly</a> for both <code>nvm</code> and <code>rvm</code>.</p><p>You can also find <a href="https://frederic-hemberger.de/articles/speed-up-initial-zsh-startup-with-lazy-loading">another interesting post</a> by Frederic about optimising Zsh loading time by converting Kubernetes&rsquo;s initialisation code into a lazy-loading function. When not using lazy-loading, you might find Adam&rsquo;s <a href="https://coderwall.com/p/j6cjnq/make-your-zsh-startup-faster-oh-my-zsh-and-rbenv-fixes">trick</a> useful for reducing <code>rbenv</code> time.</p><h3 id="optimising-completion-system">Optimising completion system</h3><p>One of the beloved Zsh&rsquo;s features is its new <a href="http://zsh.sourceforge.net/Doc/Release/Completion-System.html"><em>completion system</em></a>, so-called <a href="https://linux.die.net/man/1/zshcompsys"><em>zshcompsys</em></a>. That is, when you type half of a certain command and press <kbd>Tab</kbd>, Zsh is able to show some suggestions for completing that command.</p><p>Zsh does ship with some built-in support for popular commands but not for all kinds of commands. Instead, Zsh offers powerful means for defining custom completion via <a href="http://zsh.sourceforge.net/Doc/Release/Completion-System.html#Autoloaded-files">underscored-autoloaded files</a>.</p><p>Zsh completion system must be activated by calling function <a href="http://zsh.sourceforge.net/Doc/Release/Completion-System.html#Use-of-compinit"><code>compinit</code></a>. Most of the framework like oh-my-zsh or Prezto will take care of initialising completion system. In my case, after getting rid of big frameworks, I have to manually activate it with <code>autoload -Uz compinit &amp;&amp; compinit</code>.</p><p>Every time <code>compinit</code> is invoked, it often checks its configurations and re-generates in case of changes. Some have investigated this matter and suggested improvements such as <a href="https://gist.github.com/ctechols/ca1035271ad134841284">checking <em>compinit</em>&rsquo;s cache only once a day</a>. A similar approach has also been implemented in <a href="https://github.com/sorin-ionescu/prezto/blob/e149367445d2bcb9faa6ada365dfd56efec39de8/modules/completion/init.zsh#L34">Prezto</a>.</p><p>Here is a simple excerpt based on <a href="https://carlosbecker.com/posts/speeding-up-zsh">Carlos&rsquo;s solution</a>.</p><script src="//gist.github.com/htr3n/684032f487bb96db527647b74d9c0270.js"></script><h5 id="lessening-compinit-invocations">Lessening <code>compinit</code> invocations</h5><p>When running <code>zprof</code> to profile Zsh execution, as many others also found out, I noticed a lot of invocations to <code>compinit</code>. It was because I used some smart plugins like <a href="https://github.com/zsh-users/zsh-completions">zsh-users/zsh-completions</a> and <a href="https://github.com/zsh-users/zsh-autosuggestions">zsh-users/zsh-autosuggestions</a> and scattered <code>compinit</code> in many places. Using <a href="https://beyondgrep.com"><em>ack</em></a>, I could quickly spot and remove all <code>compinit</code>, then only call once at the end of my <a href="https://github.com/htr3n/zsh-config/blob/master/zshrc">.zshrc</a>.</p><h5 id="compiling-completion-dumped-files">Compiling completion dumped files</h5><p>Note that by default <code>compinit</code> will produce a dumped configuration for accelerating future access. The default dumped file is <code>.zcompdump</code> (which can be changed with <code>compinit -d new_dump_file</code> or totally disabled with <code>compinit -D</code>).</p><p>We can go further by compiling the dumped file with the built-in command <a href="http://zsh.sourceforge.net/Doc/Release/Shell-Builtin-Commands.html#index-compilation"><code>zcompile</code> </a>for faster autoloading of completion functions. As completion is only needed for interactive shell sessions, I put the <code>zcompile</code> code inside <a href="https://github.com/htr3n/zsh-config/blob/master/zlogin">.zlogin</a> and force it to run in background mode.</p><script src="//gist.github.com/htr3n/5a9b17eab35be60312db6d5afd67f93c.js"></script><h3 id="optimising-shell-prompts">Optimising shell prompts</h3><p>You can find a lot of frameworks or plugins offer super duper cool command line prompts like <a href="http://stevelosh.com/blog/2010/02/my-extravagant-zsh-prompt">this</a>, <a href="https://denysdovhan.com/spaceship-prompt/">this</a>, or <a href="https://github.com/bhilburn/powerlevel9k/wiki/Show-Off-Your-Config">these</a> that show rich information regarding your current working folder such as versioning status, virtual environments, and many more.</p><p>Obviously getting these information will induce extra execution time, especially for checking large versioned repositories or virtual runtime libraries. That leads to many <a href="https://github.com/robbyrussell/oh-my-zsh/pull/1570">workarounds</a>, <a href="http://marc-abramowitz.com/archives/2012/04/10/fix-for-oh-my-zsh-git-svn-prompt-slowness">tweaks</a>, <a href="https://github.com/robbyrussell/oh-my-zsh/pull/1570">hacks</a>, <a href="https://github.com/creationix/nvm/issues/539">other hacks</a>, and more <a href="https://github.com/denysdovhan/spaceship-prompt/issues/161">hacks</a>.</p><p>You might want to consider some recent approaches on speeding up shell prompts such as Anish&rsquo;s <a href="https://www.anishathalye.com/2015/02/07/an-asynchronous-shell-prompt">non-blocking prompt</a> or Sindre Sorhus&rsquo;s <a href="https://github.com/sindresorhus/pure"><em>pure</em></a> based on Mathias Fredriksson&rsquo;s <a href="https://github.com/mafredri/zsh-async">zsh-async</a>. I have tried <em>pure</em> and found out its timing is very close to <a href="https://github.com/htr3n/zsh-config/blob/master/lib/prompts-htr3n.sh">my own prompts</a> based on vanilla Zsh scripts and built-in function <a href="http://zsh.sourceforge.net/Doc/Release/User-Contributions.html#Version-Control-Information"><code>vcs_info</code></a>. Therefore, I mostly switch back and forth between these prompts in my dev box and totally satisfy with their performance thus far.</p><h3 id="macos-optimisations">MacOS-specific optimisations</h3><h4 id="path-helper">Helping <code>path_helper</code></h4><p>In the chain of Zsh startup order, <code>/etc/zprofile</code> will be sourced before <code>~/.zprofile</code>. So, macOS uses <code>/etc/profile</code> to establish paths to executable files via <a href="https://opensource.apple.com/source/shell_cmds/shell_cmds-162/path_helper/path_helper.c.auto.html"><em>path_helper</em></a>.</p><pre><code class="language-sh">$ cat /etc/zprofile
# system-wide environment settings for zsh(1)
if [ -x /usr/libexec/path_helper ]; then
	eval `/usr/libexec/path_helper -s`
fi
</code></pre><p>To do that, <em>path_helper</em> will read <code>/etc/paths</code> and <code>/etc/manpaths</code>, then read all files inside <code>/etc/paths.d</code> and <code>/etc/manpaths.d</code> and append their contents to <code>$PATH</code> and <code>$MANPATH</code>, respectively. New paths can be conveniently added by adding a plaintext file in <code>/etc/paths.d</code> instead of messing common shared configuration files.</p><p>Previously in some cases, <em>path_helper</em> might be very slow as mentioned by Michael Tsai <a href="https://mjtsai.com/blog/2009/04/01/slow-opening-terminal-windows">here</a> and even deserved a <a href="https://gist.github.com/mkhl/123525">patch</a> and a <a href="https://github.com/mgprot/path_helper">Perl based alternative</a>. I reckoned that <em>path_helper</em> is getting notably slow when the number of paths are growing but its recent version is no longer a script but 64-bit binary executable and seems to work faster.</p><p>If you notice that <em>path_helper</em> makes Zsh slow, you can just put the contents of <code>/etc/paths</code> and of all files in <code>/etc/paths.d</code> directly in <code>.zprofile</code> . After that, just comment out the corresponding code in <code>/etc/profile</code>.</p><blockquote class="warning"><strong>Warning</strong><br><p>Tinkering with system configurations like <code>/etc/zprofile</code> might be risky. And, most of the time, future system updates often reset these changes back to the default values.</p></blockquote><h4 id="optimising-login-process">Optimising login process</h4><p>The default <a href="https://opensource.apple.com/source/system_cmds/system_cmds-541/login.tproj"><em>login process</em></a> of macOS could be the culprit too. Opening a terminal window or tab will trigger <code>login -pf username</code> which, in turn, reads from and writes into the logs file in <code>/var/log/asl</code> (note <code>syslog()</code> invocations in <a href="https://opensource.apple.com/source/system_cmds/system_cmds-541/login.tproj/login.c.auto.html"><code>login.c</code></a>).</p><p>We can check this out in any terminal app. The command <code>ps -ef | grep login</code> will show details about the <code>login</code> process.</p><pre><code class="language-sh">$ ps -ef | grep login
...
  0 25142 25141   0  6:40AM ttys000    0:00.13 login -fp htr3n
</code></pre><p>In case you want to dig deeper, execute the following command in a terminal tab/window,</p><pre><code class="language-sh">$ sudo opensnoop | grep &quot;/var/log/asl&quot;
</code></pre><p>then open another tab or window to see a lot of accessing to ASLs (standing for <strong>A</strong>pple <strong>S</strong>ystem <strong>L</strong>og, deprecated since macOS 10.12 but still in use somewhere).</p><p>Thus, some have reported a <em>magic</em> that somehow speeds up shell startup by <a href="http://osxdaily.com/2010/05/06/speed-up-a-slow-terminal-by-clearing-log-files">deleting macOS ASLs</a>.</p><pre><code class="language-sh"># remove all Apple system logs -- more destructive way
$ sudo rm -rf /private/var/log/asl/*.asl
</code></pre><p>Nevertheless, these logs will continuously grow day after day. We might configure <code>/etc/asl.conf</code> to permanently reduce the amount of ASLs. Using <a href="https://en.wikipedia.org/wiki/sudo"><code>sudo</code></a> to open that file in Text Editor (or your editor of choice),</p><pre><code class="language-sh">$ sudo open -e /etc/asl.conf
</code></pre><p>then looking for the following lines and changing them accordingly and leaving the rest intact.</p><pre><code>...
# save everything from emergency to notice
# ? [&lt;= Level notice] store
? [&lt;= Level critical] store
...
</code></pre><p>The idea is to change the log level from <code>notice</code> to a higher level such as <code>warning</code>, <code>error</code>, or <code>critical</code> (see more on <em>Syslog Message Severities</em> in <a href="https://tools.ietf.org/html/rfc5424#page-11">RFC 5424</a>. You might also look further in the folder <code>/etc/asl/</code> to tinker log configurations of certain applications but that is beyond the scope of this article.</p><p>Another way is to skip the process of accessing ASLs altogether. For instance, with iTerm 2, press <kbd>⌘</kbd> + <kbd>,</kbd> to open menu <span class="menu">Preferences</span> , then go to <span class="menu">Profiles ▸ General</span> .</p><figure><img src="https://htr3n.github.io/2018/07/faster-zsh/iterm2-login.png" alt="iTerm 2 login setting" style="max-width: 100%;"><figcaption><span class="img--caption">Figure 2. iTerm 2 login setting</span></figcaption></figure><p>The same way can be applied for Apple&rsquo;s built-in Terminal app.</p><figure><img src="https://htr3n.github.io/2018/07/faster-zsh/terminal-login.png" alt="Built-in Terminal login setting" style="max-width: 100%;"><figcaption><span class="img--caption">Figure 3. Built-in Terminal login setting</span></figcaption></figure><h2 id="conclusion">Conclusion</h2><p>We have walked through some major aspects that might affect Zsh in particular, and other shells, loading time. I hope these discussions can help you to pinpoint and address your shell startup issues and have better experience working with shells and command line. This is what I got after all these effort.</p><pre><code class="language-sh">❯ for i in $(seq 1 5); do /usr/bin/time /bin/zsh -i -c exit; done
        0.31 real         0.16 user         0.13 sys
        0.28 real         0.15 user         0.12 sys
        0.28 real         0.15 user         0.12 sys
        0.28 real         0.15 user         0.12 sys
        0.28 real         0.15 user         0.12 sys
</code></pre><p>If you have any suggestions for improvement or successful tweaks, please drop a comment below.</p><h2 id="references">References</h2><ol><li><a href="https://kev.inburke.com/kevin/profiling-zsh-startup-time">https://kev.inburke.com/kevin/profiling-zsh-startup-time</a></li><li><a href="https://esham.io/2018/02/zsh-profiling">https://esham.io/2018/02/zsh-profiling</a></li><li><a href="https://carlosbecker.com/posts/speeding-up-zsh">https://carlosbecker.com/posts/speeding-up-zsh</a></li><li><a href="https://github.com/robbyrussell/oh-my-zsh/issues/5327">https://github.com/robbyrussell/oh-my-zsh/issues/5327</a></li><li><a href="https://coderwall.com/p/sladaq/faster-zsh-in-large-git-repository">https://coderwall.com/p/sladaq/faster-zsh-in-large-git-repository</a></li><li><a href="https://ahmadnazir.github.io/posts/2016-11-03-load-shell-faster/post.html">https://ahmadnazir.github.io/posts/2016-11-03-load-shell-faster/post.html</a></li><li><a href="https://superuser.com/a/47856/82870">https://superuser.com/a/47856/82870</a></li><li><a href="https://github.com/robbyrussell/oh-my-zsh">https://github.com/robbyrussell/oh-my-zsh</a></li><li><a href="https://github.com/sorin-ionescu/prezto">https://github.com/sorin-ionescu/prezto</a></li></ol></div><div class="post--navigation post--navigation-single"><a href="/2018/07/minimal-hugo-workflow/" class="post--navigation-prev"><i aria-hidden="true" class="fa fa-chevron-left"></i> <span class="navigation-tittle">A mininal Hugo blogging workflow</span> </a><a href="/2018/07/handy-quicklook/" class="post--navigation-next"><span class="navigation-tittle">Handy macOS QuickLook configurations</span> <i aria-hidden="true" class="fa fa-chevron-right"></i></a></div><div class="post__related"><h2>Related Articles</h2><ul class="related-posts"><li><span class="list__title--small"><a href="/2018/06/bootstrapping-macos-workspace/">Bootstrapping macOS workspace</a> <time class="pull-right hidden-tablet">Jun 27 &#39;18</time></span></li></ul></div><div id="disqus_thread"></div><script type="text/javascript">(function () {
    if (location.hostname === "localhost" ||
      location.hostname === "127.0.0.1" ||
      location.hostname === "") {
      return;
    }
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    var disqus_shortname = 'https-htr3n-github-io';
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || 
      document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><a href="http://disqus.com/" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a></article></div><script>var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-112764962-1', 'auto');
	
	ga('send', 'pageview');
}</script><script async src="https://www.google-analytics.com/analytics.js"></script><script defer="defer" src="https://use.fontawesome.com/releases/v5.2.0/js/all.js" integrity="sha384-4oV5EgaV02iISL2ban6c/RmotsABqE4yZxZLcYMAdG7FAPsyHYAPpywE9PJo+Khy" crossorigin="anonymous"></script><noscript id="deferred-styles"><link rel="stylesheet" type="text/css" href="https://htr3n.github.io/css/github.min.css"></noscript><script>var loadDeferredStyles = function () {
    var addStylesNode = document.getElementById("deferred-styles");
    if (addStylesNode) {
      var replacement = document.createElement("div");
      replacement.innerHTML = addStylesNode.textContent;
      document.body.appendChild(replacement);
      addStylesNode.parentElement.removeChild(addStylesNode);
    }
  };
  var raf = window.requestAnimationFrame || window.mozRequestAnimationFrame ||
    window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
  if (raf) raf(function () {
    window.setTimeout(loadDeferredStyles, 0);
  });
  else
    window.addEventListener('load', loadDeferredStyles);</script><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script><script type="text/javascript">hljs.configure({languages: []});
    hljs.initHighlightingOnLoad();</script></body></html>