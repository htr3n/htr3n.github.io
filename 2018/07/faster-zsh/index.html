<!DOCTYPE html>
<html lang="en">
<head>
<link href="https://gmpg.org/xfn/11" rel="profile">
<link rel="canonical" href="https://htr3n.github.io/2018/07/faster-zsh/">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1">
<meta name="generator" content="Hugo 0.97.0"/>
<title>Faster and enjoyable ZSH (maybe) • htr3n&#39;s</title>
<meta name="description" content="htr3n&#39;s blog :: technology, thoughts, opinions, and rants">
<meta name="keywords" content="blog,java,php,python,golang,javascript,shell,thoughts,macos,apple,tiếng việt,parental,family,apache,httpd,laravel,politics,critical thinking,chính trị,luật,hiến pháp,xã hội,gia đình">
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Faster and enjoyable ZSH (maybe)"/>
<meta name="twitter:description" content="Some handy and well-aimed investigations and optimisations could enhance the performance of your favourite ZSH."/>
<meta property="og:title" content="Faster and enjoyable ZSH (maybe)"/>
<meta property="og:description" content="Some handy and well-aimed investigations and optimisations could enhance the performance of your favourite ZSH."/>
<meta property="og:type" content="article"/>
<meta property="og:url" content="https://htr3n.github.io/2018/07/faster-zsh/"/><meta property="article:section" content="posts"/>
<meta property="article:published_time" content="2018-07-23T00:00:00+00:00"/>
<meta property="article:modified_time" content="2018-07-27T00:00:00+00:00"/>
<link href="https://fonts.googleapis.com/css?family=IBM+Plex+Serif" rel="stylesheet">
<link rel="stylesheet" href="https://htr3n.github.io/scss/hyde-hyde.css">
<link rel="stylesheet" href="https://htr3n.github.io/scss/print.css" media="print">
<!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
<link rel="shortcut icon" href="/favicon.png">
</head>
<body class="">
<div class="sidebar">
<div class="">
<div class="sidebar-about">
<span class="site__title">
<a href="https://htr3n.github.io/">htr3n&#39;s</a>
</span>
<div class="author-image">
<img src="https://htr3n.github.io//img/avatar.png" alt="Author Image" class="img--circle img--headshot element--center">
</div>
<p class="site__description">
</p>
</div>
<div class="collapsible-menu">
<input type="checkbox" id="menuToggle">
<label for="menuToggle">htr3n&#39;s</label>
<div class="menu-content">
<div>
<ul class="sidebar-nav">
<li>
<a href="/posts/">
<span>Posts</span>
</a>
</li>
<li>
<a href="/portfolio/">
<span>Portfolio</span>
</a>
</li>
<li>
<a href="/vn/">
<span>Tiếng Việt</span>
</a>
</li>
<li>
<a href="/about/">
<span>About</span>
</a>
</li>
</ul>
</div>
<section class="social">
<a href="https://twitter.com/htr3n" rel="me"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a>
<a href="https://github.com/htr3n" rel="me"><i class="fab fa-github fa-lg" aria-hidden="true"></i></a>
<a href="https://linkedin.com/in/htr3n" rel="me"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a>
<a href="https://stackoverflow.com/users/339302" rel="me"><i class="fab fa-stack-overflow fa-lg" aria-hidden="true"></i></a>
<a href="https://keybase.io/htr3n" rel="me"><i class="fab fa-keybase fa-lg" aria-hidden="true"></i></a>
<a href="mailto:hoang.huy.tran&#43;blog@gmail.com" rel="me"><i class="fas fa-at fa-lg" aria-hidden="true"></i></a>
</section>
</div>
</div>
<div class="copyright">
&copy; 2022 htr3n
<a href="https://creativecommons.org/licenses/by-sa/4.0">CC BY-SA 4.0</a>
</div>
<div class="builtwith">
Built with <a href="https://gohugo.io">Hugo</a> ❤️ <a href="https://github.com/htr3n/hyde-hyde">hyde-hyde</a>.
</div>
</div>
</div>
<div class="content container">
<article>
<header>
<h1>Faster and enjoyable ZSH (maybe)</h1>
<div class="post__meta">
<i class="fas fa-calendar-alt"></i> Jul 23, 2018 in
<a class="badge badge-category" href="/categories/dev">DEV</a>
•
<a class="badge badge-category" href="/categories/system">SYSTEM</a>
<br/>
<i class="fas fa-tags"></i>
<a class="badge badge-tag" href="/tags/zsh">zsh</a>
<a class="badge badge-tag" href="/tags/shell">shell</a>
<a class="badge badge-tag" href="/tags/macos">macos</a>
<a class="badge badge-tag" href="/tags/performance">performance</a>
<br/>
<i class="fas fa-clock"></i> 14 min read
</div>
</header>
<div class="post">
<p>Z shell (Zsh) has been my shell of choice in both Linux and macOS. I used to install <a href="https://github.com/robbyrussell/oh-my-zsh">oh-my-zsh</a> or the claimed-to-be-faster <a href="https://github.com/sorin-ionescu/prezto">Prezto</a> or <a href="https://github.com/zimfw/zimfw">Zim</a> to leverage some of their cool libraries.</p>
<p>Unfortunately, I realised that my favourite terminal app, <a href="https://www.iterm2.com">iTerm 2</a>, became more and more sluggish when loading a new tab or window with more than one and a half second (without some virtual environment loaders like <a href="https://github.com/creationix/nvm">nvm</a>, <a href="https://rvm.io/">rvm</a>, <a href="https://github.com/rbenv/rbenv">rbenv</a>, <a href="http://www.jenv.be">jenv</a>).</p>
<p>A quick <a href="https://www.google.com/search?q=faster+zsh"><em>G-fu</em></a> could yield numerous posts on how to debug, optimise, speed up Zsh. I spent some time to refactor my own lightweight scripts instead of using big frameworks and was able to reach nearly one third of a second. In this post, I will share and discuss some aspects that might affect Zsh loading time and how to mitigate them. Most of the relevant code and configurations can be found <a href="https://github.com/htr3n/zsh-config">here</a>.</p>
<blockquote>
<p><strong>TL;DR:</strong>There are many aspects in Zsh that can potentially slow down its startup time and can be mitigated.</p>
<ul>
<li><a href="#organising-shell-startup-order">Organising shell startup order</a></li>
<li><a href="#avoiding-creating-subprocesses">Avoiding creating subprocesses</a></li>
<li><a href="#lazy-loading">Lazy-loading instead of eager-loading</a></li>
<li><a href="#optimising-completion-system">Optimising completion system</a></li>
<li><a href="#optimising-shell-prompts">Optimising shell prompts</a></li>
<li><a href="#macos-optimisations">MacOS-specific optimisations</a></li>
</ul>
</blockquote>
<h2 id="performance-analysis">Performance Analysis</h2>
<h3 id="overall-execution-time">Overall execution time</h3>
<p>Crunching some numbers on Zsh loading time would be definitely useful for further in depth analysis of its performance. A simple timing of Zsh startup time can be measured approximately using the <code>time</code> command that is available in most Unix/Linux/Mac systems.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ /usr/bin/time /bin/zsh -i -c exit
</span></span><span style="display:flex;"><span>        0.67 real         0.41 user         0.26 sys
</span></span></code></pre></div><p>The output of the command shows the execution time of Zsh breaking down to user-land and system. In order to get a better approximation, we can make a loop that invokes <code>time</code> for 10 or greater, if possible.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i in <span style="color:#66d9ef">$(</span>seq <span style="color:#ae81ff">1</span> 10<span style="color:#66d9ef">)</span>; <span style="color:#66d9ef">do</span> /usr/bin/time /bin/zsh -i -c exit; <span style="color:#66d9ef">done</span>;
</span></span></code></pre></div><p>This timing method is very fast and handy in case you want to quickly see how your Zsh performs, especially to test some changes you have just made.</p>
<h3 id="profiling">Profiling</h3>
<p>Zsh provides a built-in module <a href="http://zsh.sourceforge.net/Doc/Release/Zsh-Modules.html#The-zsh_002fzprof-Module"><code>zsh/zprof</code></a> that can be used to profile Zsh functions. At the beginning of <code>~/.zshrc</code>, we add <code>zmodload zsh/zprof</code>. After restart the shell, we can use the command <code>zprof</code> to show a very rich output on Zsh startup loading. An illustrative output of <code>zprof</code> is shown below.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ zprof
</span></span><span style="display:flex;"><span>num  calls                time                       self            name
</span></span><span style="display:flex;"><span>------------------------------------------------------------------------------
</span></span><span style="display:flex;"><span> 1<span style="color:#f92672">)</span>    <span style="color:#ae81ff">1</span>          51.31    51.31   22.68%     49.68    49.68   21.96%  zle-line-init
</span></span><span style="display:flex;"><span> 2<span style="color:#f92672">)</span>    <span style="color:#ae81ff">2</span>          45.72    22.86   20.21%     45.72    22.86   20.21%  compaudit
</span></span><span style="display:flex;"><span> 3<span style="color:#f92672">)</span>  <span style="color:#ae81ff">195</span>          34.71     0.18   15.34%     25.52     0.13   11.28%  _zsh_autosuggest_bind_widget
</span></span><span style="display:flex;"><span> ...
</span></span></code></pre></div><blockquote>
<p><strong>Note</strong></p>
<p>Two aforementioned approaches can give us a rough analysis on what aspects are invoked during Zsh startup so that we might figure out the bottleneck. In case you need to dig deeper, Arnout wrote <a href="http://blog.xebia.com/profiling-zsh-shell-scripts">a nice article</a> in which he suggested a in-depth analysis and visualisation of Zsh loading using <code>xtrace</code> and <code>kcachegrind</code>. Benjamin developed <a href="https://esham.io/2018/02/zsh-profiling">a similar approach</a> to more thorough tracing and analysis Zsh execution.</p>
</blockquote>
<h2 id="problematic-aspects-and-mitigation">Problematic Aspects and Mitigation</h2>
<p>Using two simple methods mentioned above, I was able to roughly understand some issues of my Zsh settings and tried to mitigate them to reduce startup time. I could not report the exact steps what have been done as it was a lot of trial-and-errors. Here I will discuss some major aspects combining my actual experiment and G-fu research.</p>
<h3 id="organising-shell-startup-order">Organising shell startup order</h3>
<p>The order that Zsh loads its configuration files are documented <a href="http://zsh.sourceforge.net/Intro/intro_3.html">here</a> and <a href="http://zsh.sourceforge.net/Doc/Release/Files.html">here</a>. Peter Ward <a href="https://blog.flowblok.id.au/2013-02/shell-startup-scripts.html">drew a nice diagram</a> showing the loading process of Zsh alongside with Bash and Sh (note that he omitted the system-wide configurations in Zsh part).</p>
<figure>
<img src="https://htr3n.github.io/2018/07/faster-zsh/shell-startup-actual.png" alt="Shell startup order" style="max-width: 100%;"/>
<figcaption>
<span class="img--caption">
Figure 1. Bash, sh, and zsh shells startup order [<a href="https://blog.flowblok.id.au/2013-02/shell-startup-scripts.html">source</a>]
</span>
</figcaption>
</figure>
<p>It&rsquo;s also useful to understand relevant shell concepts, such as <em>login</em> vs. <em>non-login</em>, <em>interactive</em> vs. <em>non-interactive</em> shown in the diagram. Please refer to, for example, <a href="https://askubuntu.com/a/438170/115425">here</a> or <a href="https://askubuntu.com/a/879400/115425">here</a> for further explanations.</p>
<blockquote>
<p><strong>Some shell examples:</strong></p>
<ul>
<li>when opening a terminal emulator app (e.g. Terminal or iTerm 2), we are creating an <em>interactive, non-login shell</em> (please see <code>login -pf</code> later).</li>
<li>when logging in into a machine using command line <a href="https://en.wikipedia.org/wiki/Secure_Shell"><code>ssh</code></a> or <a href="https://en.wikipedia.org/wiki/Su_%28Unix%29"><code>su - username</code></a>, we are working with an <em>interactive login</em> shell.</li>
<li>when executing a shell script, it is on a <em>non-interactive</em>, <em>non-login</em> shell.</li>
</ul>
</blockquote>
<p>Grokking Zsh startup order will help us putting relevant configurations in right files as well as optimising the loading process. My local Zsh setting is orgranised as follow:</p>
<ul>
<li><code>.zshenv</code>: invoked by all invocations of Zsh, so we should keep it small and merely initialise necessary variables.</li>
<li><code>.zlogin</code>: will be loaded in login shells after <em>.zshrc</em>. My <a href="https://github.com/htr3n/zsh-config/blob/master/zlogin"><em>.zlogin</em></a> will compile <code>zcompdump</code> in background as this is time-consuming and done only once per log-in session.</li>
<li><code>.zprofile</code> : similar to <em>.zlogin</em> but will be sourced before <em>.zshrc</em>. Note that, both <em>.zprofile</em> and <em>.zshrc</em> are skipped in non-login non-interactive shells, as shown in Figure 1. So I learned a trick from <a href="https://github.com/sorin-ionescu/prezto/tree/master/runcoms">Prezto</a> that declares environment variables in <em>.zprofile</em> and uses <em>.zshenv</em> to source <em>.zprofile</em> (e.g. <a href="https://github.com/htr3n/zsh-config/blob/master/zprofile"><em>.zprofile</em></a> and <a href="https://github.com/htr3n/zsh-config/blob/master/zshenv"><em>.zshenv</em></a>). This way, non-login non-interactive shells will receive proper variable initialisations.</li>
<li><code>.zshrc</code>: will be sourced in interactive shells. This contains the main part of Zsh configuration (e.g. my <a href="https://github.com/htr3n/zsh-config/blob/master/zshrc"><em>.zshrc</em></a>).</li>
</ul>
<h3 id="avoiding-creating-subprocesses">Avoiding creating subprocesses</h3>
<p>Some commands look totally innocent and standard in your shell scripts but might cost you dearly. Among them are commands that launch new <a href="http://tldp.org/LDP/abs/html/othertypesv.html#CHILDREF2">child processes</a> such as <a href="http://zsh.sourceforge.net/Doc/Release/Expansion.html#Command-Substitution"><em>command substitutions</em></a> and <a href="https://www.unix.com/man-page/posix/1posix/eval"><em>eval</em> commands</a>.</p>
<p><strong>Command Substitutions</strong></p>
<p>In Zsh, a command enclosed in <code>$(command)</code> or quoted with backticks <code>`command`</code> will be replaced with its standard output. Thus, it is very popular in Unix/Linux world when one wants to execute a command and get the output to process further on. The bad thing is that <em>command substitution</em> will launch a new process (i.e. a <a href="http://tldp.org/LDP/abs/html/subshells.html#SUBSHELLSREF">subshell</a>).</p>
<p><strong><code>eval</code> command</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>eval <span style="color:#f92672">[</span>arg...<span style="color:#f92672">]</span>
</span></span></code></pre></div><p>The command <code>eval</code> (sounds with <em>evil</em>, ^_O) is part of POSIX standard and is available in most shells. It&rsquo;s often used together with <em>command substitution</em>. Essentially, <code>eval</code> concats its arguments separated with spaces along with evaluating any variables or expressions to form a command with or without arguments. Then it executes the resulting command in the current shell. As such, <code>eval</code> will cause side-effects as it must evaluate the inputs and perform expansions, if any.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ command<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;print &#39;Hello World&#39;&#34;</span>
</span></span><span style="display:flex;"><span>$ command			   <span style="color:#75715e"># nothing happen</span>
</span></span><span style="display:flex;"><span>$ eval $command
</span></span><span style="display:flex;"><span>Hello World
</span></span></code></pre></div><p>This feature makes <code>eval</code> powerful as it can dynamically evaluate and execute code. But dynamic evaluation also makes <code>eval</code> risky and time-consuming.</p>
<p>In some cases, for instance, simple string manipulation, we can consider to replace command substitutions and <code>eval</code> commands that invoke <code>sed</code>, <code>awk</code>, etc., with Zsh built-in constructs or hard-coded constants. Zsh provides numerous powerful built-in mechanisms for substring matchings, string explosion/splitting, and <a href="http://zsh.sourceforge.net/Doc/Release/Expansion.html">expansions</a>.</p>
<p>For instance, when using <a href="https://brew.sh">Homebrew</a>, it is very convenient to get the path to an installed package using <code>$(brew --prefix &lt;package&gt;)</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>export PATH<span style="color:#f92672">=</span>$PATH:<span style="color:#e6db74">&#34;</span><span style="color:#66d9ef">$(</span>brew --prefix httpd<span style="color:#66d9ef">)</span><span style="color:#e6db74">/bin&#34;</span>
</span></span></code></pre></div><p>It turns out many calls to <code>$(brew --prefix ...)</code> would launch many subprocesses and thus <a href="https://kev.inburke.com/kevin/profiling-zsh-startup-time">slow down Zsh notably</a>. When replacing that <code>$()</code> command with its actual output, I could gain certain improvement. The caveat is that some upgraded versions might break these hard-coded values.</p>
<h3 id="lazy-loading"><em>Lazy-loading</em> instead of <em>eager-loading</em></h3>
<h4 id="function-autoloading">Function autoloading</h4>
<p>We can define and source new functions in Zsh. In this way, a function is <em>eagerly loaded</em> and always available for use. Note that most of these functions might be not really needed until being invoked.</p>
<p>Zsh can help postponing their loading time and allow to <em>load-on-demand</em> via <a href="http://zsh.sourceforge.net/Doc/Release/Functions.html#Autoloading-Functions">function autoloading</a>. This technique is often called <em>lazy loading</em>. Performance-wise, <em>lazy loading</em> will put less pressure to the underlying system and reduce memory footprint. The same techniques are also preferred in many other fields such as databases, dynamic runtime libraries, etc.</p>
<p>In my codebase, I create a folder, namely, <code>autoloaded</code>, to store functions that will be, er&hellip;, autoloaded by Zsh. For each function, for instance, <code>function hello(){...}</code>, I will create a corresponding file named <code>hello</code> inside <code>autoloaded</code>. The content of that file is the function body (i.e. without <code>function</code> and <code>(){}</code>).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ mkdir autoloaded
</span></span><span style="display:flex;"><span>$ echo <span style="color:#e6db74">&#34;print &#39;Hello World&#39;&#34;</span> &gt;&gt; autoloaded/hello
</span></span><span style="display:flex;"><span>$ tree
</span></span><span style="display:flex;"><span>.
</span></span><span style="display:flex;"><span>└── autoloaded
</span></span><span style="display:flex;"><span>    └── hello
</span></span></code></pre></div><p>The folder <code>autoloaded</code> must be added to ZSH variable <code>fpath</code> where ZSH will look for function definitions.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-zsh" data-lang="zsh"><span style="display:flex;"><span><span style="color:#75715e"># add &#39;autoload&#39; to fpath</span>
</span></span><span style="display:flex;"><span>$ fpath<span style="color:#f92672">=(</span>$fpath autoloaded<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># try to invoke &#39;hello&#39;</span>
</span></span><span style="display:flex;"><span>$ hello
</span></span><span style="display:flex;"><span>zsh: command not found: hello
</span></span><span style="display:flex;"><span><span style="color:#75715e"># now mark `hello` for autoloading.</span>
</span></span><span style="display:flex;"><span>$ autoload hello
</span></span><span style="display:flex;"><span><span style="color:#75715e"># quickly check how `hello` will be loaded.</span>
</span></span><span style="display:flex;"><span>$ which hello
</span></span><span style="display:flex;"><span>hello <span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># undefined</span>
</span></span><span style="display:flex;"><span>	builtin autoload -X
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># now it works fine</span>
</span></span><span style="display:flex;"><span>$ hello
</span></span><span style="display:flex;"><span>Hello World
</span></span></code></pre></div><p>The body of <code>hello</code> was marked with <code>#undefined</code> along with <code>builtin autoload -X</code> meaning it will be loaded on-demand. The first time <code>hello</code> is called, Zsh will automatically load and execute it.</p>
<p>In the same way, I configured Zsh to load all of my functions on-demand to reduce memory and loading time.</p>
<blockquote>
<p><strong>Note</strong>:In <a href="https://github.com/htr3n/zsh-config">my scripts</a>, <code>autoload -Uz function_name</code> was used. The option <code>-U</code> prevents alias from being expanded. That is, whenever you define an alias and a function having the same name, the alias will be considered first instead, so <code>-U</code> just skips alias expansion. And the option <code>-z</code> indicates that the function will be auto-loaded using <code>zsh</code> or <code>ksh</code> style.</p>
</blockquote>
<h4 id="loading-virtual-environments">Selective- or lazy-loading virtual environments</h4>
<p>Many virtual environment loaders like <a href="https://rvm.io/">rvm</a>, <a href="https://github.com/rbenv/rbenv">rbenv</a>, <a href="http://www.jenv.be">jenv</a>, <a href="https://github.com/creationix/nvm">nvm</a> have been developed to manage different run-time versions and libraries. While being very handy for software development, most of these tools need to be <em>eagerly loaded</em> (e.g. directly <code>source</code> in <code>.zshrc</code>) to work properly.</p>
<p>Instead, we can consider to transform these loaders as much as possible into <em>on-demand</em> wrapper functions. You can find a good example <a href="https://peterlyons.com/problog/2018/01/zsh-lazy-loading">here</a>. In summary, Peter&rsquo;s trick is to override <code>nvm</code> with his own autoloaded <code>nvm()</code> (that eventually invokes the original <code>nvm</code> loader). Carlos also went to same way for <code>rbenv</code>, his own <code>antibody</code>, <code>pyenv</code> and achieved <a href="https://carlosbecker.com/posts/speeding-up-zsh">some good results</a>. Benny C. Wong <a href="http://bennycwong.github.io/post/speeding-up-oh-my-zsh/">did similarly</a> for both <code>nvm</code> and <code>rvm</code>.</p>
<p>You can also find <a href="https://frederic-hemberger.de/articles/speed-up-initial-zsh-startup-with-lazy-loading">another interesting post</a> by Frederic about optimising Zsh loading time by converting Kubernetes&rsquo;s initialisation code into a lazy-loading function. When not using lazy-loading, you might find Adam&rsquo;s <a href="https://coderwall.com/p/j6cjnq/make-your-zsh-startup-faster-oh-my-zsh-and-rbenv-fixes">trick</a> useful for reducing <code>rbenv</code> time.</p>
<h3 id="optimising-completion-system">Optimising completion system</h3>
<p>One of the beloved Zsh&rsquo;s features is its new <a href="http://zsh.sourceforge.net/Doc/Release/Completion-System.html"><em>completion system</em></a>, so-called <a href="https://linux.die.net/man/1/zshcompsys"><em>zshcompsys</em></a>. That is, when you type half of a certain command and press Tab, Zsh is able to show some suggestions for completing that command.</p>
<p>Zsh does ship with some built-in support for popular commands but not for all kinds of commands. Instead, Zsh offers powerful means for defining custom completion via <a href="http://zsh.sourceforge.net/Doc/Release/Completion-System.html#Autoloaded-files">underscored-autoloaded files</a>.</p>
<p>Zsh completion system must be activated by calling function <a href="http://zsh.sourceforge.net/Doc/Release/Completion-System.html#Use-of-compinit"><code>compinit</code></a>. Most of the framework like oh-my-zsh or Prezto will take care of initialising completion system. In my case, after getting rid of big frameworks, I have to manually activate it with <code>autoload -Uz compinit &amp;&amp; compinit</code>.</p>
<p>Every time <code>compinit</code> is invoked, it often checks its configurations and re-generates in case of changes. Some have investigated this matter and suggested improvements such as <a href="https://gist.github.com/ctechols/ca1035271ad134841284">checking <em>compinit</em>&rsquo;s cache only once a day</a>. A similar approach has also been implemented in <a href="https://github.com/sorin-ionescu/prezto/blob/e149367445d2bcb9faa6ada365dfd56efec39de8/modules/completion/init.zsh#L34">Prezto</a>.</p>
<p>Here is a simple excerpt based on <a href="https://carlosbecker.com/posts/speeding-up-zsh">Carlos&rsquo;s solution</a>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-zsh" data-lang="zsh"><span style="display:flex;"><span>autoload -Uz compinit
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> <span style="color:#66d9ef">$(</span>date +<span style="color:#e6db74">&#39;%j&#39;</span><span style="color:#66d9ef">)</span> !<span style="color:#f92672">=</span> <span style="color:#66d9ef">$(</span>/usr/bin/stat -f <span style="color:#e6db74">&#39;%Sm&#39;</span> -t <span style="color:#e6db74">&#39;%j&#39;</span> <span style="color:#e6db74">${</span>ZDOTDIR<span style="color:#66d9ef">:-</span>$HOME<span style="color:#e6db74">}</span>/.zcompdump<span style="color:#66d9ef">)</span> <span style="color:#f92672">]</span>; <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>  compinit
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>  compinit -C
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fi</span>
</span></span></code></pre></div><h4 id="lessening-compinit-invocations">Lessening <code>compinit</code> invocations</h4>
<p>When running <code>zprof</code> to profile Zsh execution, as many others also found out, I noticed a lot of invocations to <code>compinit</code>. It was because I used some smart plugins like <a href="https://github.com/zsh-users/zsh-completions">zsh-users/zsh-completions</a> and <a href="https://github.com/zsh-users/zsh-autosuggestions">zsh-users/zsh-autosuggestions</a> and scattered <code>compinit</code> in many places. Using <a href="https://beyondgrep.com"><em>ack</em></a>, I could quickly spot and remove all <code>compinit</code>, then only call once at the end of my <a href="https://github.com/htr3n/zsh-config/blob/master/zshrc">.zshrc</a>.</p>
<h4 id="compiling-completion-dumped-files">Compiling completion dumped files</h4>
<p>Note that by default <code>compinit</code> will produce a dumped configuration for accelerating future access. The default dumped file is <code>.zcompdump</code> (which can be changed with <code>compinit -d new_dump_file</code> or totally disabled with <code>compinit -D</code>).</p>
<p>We can go further by compiling the dumped file with the built-in command <a href="http://zsh.sourceforge.net/Doc/Release/Shell-Builtin-Commands.html#index-compilation"><code>zcompile</code> </a>for faster autoloading of completion functions. As completion is only needed for interactive shell sessions, I put the <code>zcompile</code> code inside <a href="https://github.com/htr3n/zsh-config/blob/master/zlogin">.zlogin</a> and force it to run in background mode.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-zsh" data-lang="zsh"><span style="display:flex;"><span><span style="color:#75715e"># Execute code in the background to not affect the current session</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Compile zcompdump, if modified, to increase startup speed.</span>
</span></span><span style="display:flex;"><span>  zcompdump<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>ZDOTDIR<span style="color:#66d9ef">:-</span>$HOME<span style="color:#e6db74">}</span><span style="color:#e6db74">/.zcompdump&#34;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#f92672">[[</span> -s <span style="color:#e6db74">&#34;</span>$zcompdump<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">(</span>! -s <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>zcompdump<span style="color:#e6db74">}</span><span style="color:#e6db74">.zwc&#34;</span> <span style="color:#f92672">||</span> <span style="color:#e6db74">&#34;</span>$zcompdump<span style="color:#e6db74">&#34;</span> -nt <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>zcompdump<span style="color:#e6db74">}</span><span style="color:#e6db74">.zwc&#34;</span><span style="color:#f92672">)</span> <span style="color:#f92672">]]</span>; <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>    zcompile <span style="color:#e6db74">&#34;</span>$zcompdump<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">fi</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span> &amp;!
</span></span></code></pre></div><h3 id="optimising-shell-prompts">Optimising shell prompts</h3>
<p>You can find a lot of frameworks or plugins offer super duper cool command line prompts like <a href="http://stevelosh.com/blog/2010/02/my-extravagant-zsh-prompt">this</a>, <a href="https://denysdovhan.com/spaceship-prompt/">this</a>, or <a href="https://github.com/bhilburn/powerlevel9k/wiki/Show-Off-Your-Config">these</a> that show rich information regarding your current working folder such as versioning status, virtual environments, and many more.</p>
<p>Obviously getting these information will induce extra execution time, especially for checking large versioned repositories or virtual runtime libraries. That leads to many <a href="https://github.com/robbyrussell/oh-my-zsh/pull/1570">workarounds</a>, <a href="http://marc-abramowitz.com/archives/2012/04/10/fix-for-oh-my-zsh-git-svn-prompt-slowness">tweaks</a>, <a href="https://github.com/robbyrussell/oh-my-zsh/pull/1570">hacks</a>, <a href="https://github.com/creationix/nvm/issues/539">other hacks</a>, and more <a href="https://github.com/denysdovhan/spaceship-prompt/issues/161">hacks</a>.</p>
<p>You might want to consider some recent approaches on speeding up shell prompts such as Anish&rsquo;s <a href="https://www.anishathalye.com/2015/02/07/an-asynchronous-shell-prompt">non-blocking prompt</a> or Sindre Sorhus&rsquo;s <a href="https://github.com/sindresorhus/pure"><em>pure</em></a> based on Mathias Fredriksson&rsquo;s <a href="https://github.com/mafredri/zsh-async">zsh-async</a>. I have tried <em>pure</em> and found out its timing is very close to <a href="https://github.com/htr3n/zsh-config/blob/master/lib/prompts-htr3n.sh">my own prompts</a> based on vanilla Zsh scripts and built-in function <a href="http://zsh.sourceforge.net/Doc/Release/User-Contributions.html#Version-Control-Information"><code>vcs_info</code></a>. Therefore, I mostly switch back and forth between these prompts in my dev box and totally satisfy with their performance thus far.</p>
<h3 id="macos-optimisations">MacOS-specific optimisations</h3>
<h4 id="path-helper">Optimising <code>path_helper</code></h4>
<p>In the chain of Zsh startup order, <code>/etc/zprofile</code> will be sourced before <code>~/.zprofile</code>. So, macOS uses <code>/etc/profile</code> to establish paths to executable files via <a href="https://opensource.apple.com/source/shell_cmds/shell_cmds-162/path_helper/path_helper.c.auto.html"><em>path_helper</em></a>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ cat /etc/zprofile
</span></span><span style="display:flex;"><span><span style="color:#75715e"># system-wide environment settings for zsh(1)</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> -x /usr/libexec/path_helper <span style="color:#f92672">]</span>; <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>	eval <span style="color:#e6db74">`</span>/usr/libexec/path_helper -s<span style="color:#e6db74">`</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fi</span>
</span></span></code></pre></div><p>To do that, <em>path_helper</em> will read <code>/etc/paths</code> and <code>/etc/manpaths</code>, then read all files inside <code>/etc/paths.d</code> and <code>/etc/manpaths.d</code> and append their contents to <code>$PATH</code> and <code>$MANPATH</code>, respectively. New paths can be conveniently added by adding a plaintext file in <code>/etc/paths.d</code> instead of messing common shared configuration files.</p>
<p>Previously in some cases, <em>path_helper</em> might be very slow as mentioned by Michael Tsai <a href="https://mjtsai.com/blog/2009/04/01/slow-opening-terminal-windows">here</a> and even deserved a <a href="https://gist.github.com/mkhl/123525">patch</a> and a <a href="https://github.com/mgprot/path_helper">Perl based alternative</a>. I reckoned that <em>path_helper</em> is getting notably slow when the number of paths are growing but its recent version is no longer a script but 64-bit binary executable and seems to work faster.</p>
<p>If you notice that <em>path_helper</em> makes Zsh slow, you can just put the contents of <code>/etc/paths</code> and of all files in <code>/etc/paths.d</code> directly in <code>.zprofile</code> . After that, just comment out the corresponding code in <code>/etc/profile</code>.</p>
<h4 id="optimising-login-process">Optimising the login process</h4>
<p>The default <a href="https://opensource.apple.com/source/system_cmds/system_cmds-541/login.tproj"><em>login process</em></a> of macOS could be the culprit too. Opening a terminal window or tab will trigger <code>login -pf username</code> which, in turn, reads from and writes into the logs file in <code>/var/log/asl</code> (note <code>syslog()</code> invocations in <a href="https://opensource.apple.com/source/system_cmds/system_cmds-541/login.tproj/login.c.auto.html"><code>login.c</code></a>).</p>
<p>We can check this out in any terminal app. The command <code>ps -ef | grep login</code> will show details about the <code>login</code> process.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ ps -ef | grep login
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>  <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">25142</span> <span style="color:#ae81ff">25141</span>   <span style="color:#ae81ff">0</span>  6:40AM ttys000    0:00.13 login -fp htr3n
</span></span></code></pre></div><p>In case you want to dig deeper, execute the following command in a terminal tab/window,</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ sudo opensnoop | grep <span style="color:#e6db74">&#34;/var/log/asl&#34;</span>
</span></span></code></pre></div><p>then open another tab or window to see a lot of accessing to ASLs (standing for <strong>A</strong>pple <strong>S</strong>ystem <strong>L</strong>og, deprecated since macOS 10.12 but still in use somewhere).</p>
<p>Thus, some have reported a <em>magic</em> that somehow speeds up shell startup by <a href="http://osxdaily.com/2010/05/06/speed-up-a-slow-terminal-by-clearing-log-files">deleting macOS ASLs</a>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># remove all Apple system logs -- more destructive way</span>
</span></span><span style="display:flex;"><span>$ sudo rm -rf /private/var/log/asl/*.asl
</span></span></code></pre></div><p>Nevertheless, these logs will continuously grow day after day. We might configure <code>/etc/asl.conf</code> to permanently reduce the amount of ASLs. Using <a href="https://en.wikipedia.org/wiki/sudo"><code>sudo</code></a> to open that file in Text Editor (or your editor of choice),</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ sudo open -e /etc/asl.conf
</span></span></code></pre></div><p>then looking for the following lines and changing them accordingly and leaving the rest intact.</p>
<pre tabindex="0"><code>...
# save everything from emergency to notice
# ? [&lt;= Level notice] store
? [&lt;= Level critical] store
...
</code></pre><p>The idea is to change the log level from <code>notice</code> to a higher level such as <code>warning</code>, <code>error</code>, or <code>critical</code> (see more on <em>Syslog Message Severities</em> in <a href="https://tools.ietf.org/html/rfc5424#page-11">RFC 5424</a>. You might also look further in the folder <code>/etc/asl/</code> to tinker log configurations of certain applications but that is beyond the scope of this article.</p>
<p>Another way is to skip the process of accessing ASLs altogether. For instance, with iTerm 2, press ⌘ + , to open menu <span class="menu">Preferences</span>
, then go to <span class="menu">Profiles ▸ General</span>
.</p>
<figure>
<img src="https://htr3n.github.io/2018/07/faster-zsh/iterm2-login.png" alt="iTerm 2 login setting" style="max-width: 100%;"/>
<figcaption>
<span class="img--caption">
Figure 2. iTerm 2 login setting
</span>
</figcaption>
</figure>
<p>The same way can be applied for Apple&rsquo;s built-in Terminal app.</p>
<figure>
<img src="https://htr3n.github.io/2018/07/faster-zsh/terminal-login.png" alt="Built-in Terminal login setting" style="max-width: 100%;"/>
<figcaption>
<span class="img--caption">
Figure 3. Built-in Terminal login setting
</span>
</figcaption>
</figure>
<h2 id="conclusion">Conclusion</h2>
<p>We have walked through some major aspects that might affect Zsh in particular, and other shells, loading time. I hope these discussions can help you to pinpoint and address your shell startup issues and have better experience working with shells and command line. This is what I got after all these effort.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>❯ <span style="color:#66d9ef">for</span> i in <span style="color:#66d9ef">$(</span>seq <span style="color:#ae81ff">1</span> 5<span style="color:#66d9ef">)</span>; <span style="color:#66d9ef">do</span> /usr/bin/time /bin/zsh -i -c exit; <span style="color:#66d9ef">done</span>
</span></span><span style="display:flex;"><span>        0.31 real         0.16 user         0.13 sys
</span></span><span style="display:flex;"><span>        0.28 real         0.15 user         0.12 sys
</span></span><span style="display:flex;"><span>        0.28 real         0.15 user         0.12 sys
</span></span><span style="display:flex;"><span>        0.28 real         0.15 user         0.12 sys
</span></span><span style="display:flex;"><span>        0.28 real         0.15 user         0.12 sys
</span></span></code></pre></div><p>If you have any suggestions for improvement or successful tweaks, please drop a comment below.</p>
<h2 id="reading-list">Reading List</h2>
<ol>
<li><a href="https://kev.inburke.com/kevin/profiling-zsh-startup-time">https://kev.inburke.com/kevin/profiling-zsh-startup-time</a></li>
<li><a href="https://esham.io/2018/02/zsh-profiling">https://esham.io/2018/02/zsh-profiling</a></li>
<li><a href="https://carlosbecker.com/posts/speeding-up-zsh">https://carlosbecker.com/posts/speeding-up-zsh</a></li>
<li><a href="https://github.com/robbyrussell/oh-my-zsh/issues/5327">https://github.com/robbyrussell/oh-my-zsh/issues/5327</a></li>
<li><a href="https://coderwall.com/p/sladaq/faster-zsh-in-large-git-repository">https://coderwall.com/p/sladaq/faster-zsh-in-large-git-repository</a></li>
<li><a href="https://ahmadnazir.github.io/posts/2016-11-03-load-shell-faster/post.html">https://ahmadnazir.github.io/posts/2016-11-03-load-shell-faster/post.html</a></li>
<li><a href="https://superuser.com/a/47856/82870">https://superuser.com/a/47856/82870</a></li>
<li><a href="https://github.com/robbyrussell/oh-my-zsh">https://github.com/robbyrussell/oh-my-zsh</a></li>
<li><a href="https://github.com/sorin-ionescu/prezto">https://github.com/sorin-ionescu/prezto</a></li>
</ol>
</div>
<div class="navigation navigation-single">
<a href="/2018/07/minimal-hugo-workflow/" class="navigation-prev">
<i aria-hidden="true" class="fa fa-chevron-left"></i>
<span class="navigation-tittle">A mininal Hugo blogging workflow</span>
</a>
<a href="/2018/07/handy-quicklook/" class="navigation-next">
<span class="navigation-tittle">Handy macOS QuickLook configurations</span>
<i aria-hidden="true" class="fa fa-chevron-right"></i>
</a>
</div>
<div class="post__related">
<h2>Related Articles</h2>
<ul class="related-posts">
<li>
<span class="list__title--small">
<a href="/2018/06/bootstrapping-macos-workspace/">Bootstrapping macOS workspace</a>
<time class="pull-right hidden-tablet">Jun 27, 2018</time>
</span>
</li>
</ul>
</div>
<div id="disqus_thread"></div>
<script type="text/javascript">
(function () {
    if (location.hostname === "localhost" ||
      location.hostname === "127.0.0.1" ||
      location.hostname === "") {
      return;
    }
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    var disqus_shortname = 'https-htr3n-github-io';
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || 
      document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>
Please enable JavaScript to view the
<a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a>
</noscript>
<a href="http://disqus.com/" class="dsq-brlink">comments powered by
<span class="logo-disqus">Disqus</span>
</a>
</article>
</div>
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-112764962-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src="https://www.google-analytics.com/analytics.js"></script>
<script defer="defer" src="https://use.fontawesome.com/releases/v5.12.1/js/all.js" integrity="sha384-ZbbbT1gw3joYkKRqh0kWyRp32UAvdqkpbLedQJSlnI8iLQcFVxaGyrOgOJiDQTTR" crossorigin="anonymous"></script>
<noscript id="deferred-styles">
<link rel="stylesheet" type="text/css" href="/css/ocean.min.css"/>
<link rel="stylesheet" type="text/css" href="/css/codecopy.min.css"/>
</noscript>
<script>
var loadDeferredStyles = function () {
    var addStylesNode = document.getElementById("deferred-styles");
    if (addStylesNode) {
      var replacement = document.createElement("div");
      replacement.innerHTML = addStylesNode.textContent;
      document.body.appendChild(replacement);
      addStylesNode.parentElement.removeChild(addStylesNode);
    }
  };
  var raf = window.requestAnimationFrame || window.mozRequestAnimationFrame ||
    window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
  if (raf) raf(function () {
    window.setTimeout(loadDeferredStyles, 0);
  });
  else
    window.addEventListener('load', loadDeferredStyles);
  
  document.addEventListener('DOMContentLoaded', function (event) {
    codecopy('pre');
  });
</script>
<script defer="defer" src="/js/codecopy.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/highlight.min.js"></script>
<script type="text/javascript">
hljs.initHighlightingOnLoad();
</script>
</body>
</html>
